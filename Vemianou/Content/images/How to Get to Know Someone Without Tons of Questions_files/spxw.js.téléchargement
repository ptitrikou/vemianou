(function(iframeContent) {"use strict";function createIframe(){var e=window.document,t=e.body;if(null==t&&--numberOfWaits)return void setTimeout(createIframe,100);var r=e.createElement("div"),n=e.createElement("div"),o=e.createElement("iframe");r.style.display="none",r.appendChild(n),t.insertBefore(r,t.firstChild),o.frameBorder="0",o.id="SPX_IFRAME_"+(new Date).getTime(),o.allowTransparency="true",n.appendChild(o);try{o.contentWindow.document.open()}catch(e){o.src=docSrc}o.contentWindow.isBookmarklet=document.currentScript&&/bookmarklet=/.test(document.currentScript.src)?"1":"0",o.contentWindow.document.write(iframeHTML),o.contentWindow.document.close()}var iframeHTML=["<!DOCTYPE html>","<html>","<head>",'<meta charset="UTF-8">','<meta name="referrer" content="no-referrer">','<meta name="referrer" content="never">',"</head>","<body>",'<script type="text/javascript" charset="UTF-8">',iframeContent,"<\/script>","</body>","</html>"].join(""),docSrc=["javas","cript:","var d = document.open();",'d.domain="',window.document.domain,'";',"void(0);"].join(""),numberOfWaits=100;createIframe();})('/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window["webpackJsonp"];\n/******/ \twindow["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add "moreModules" to the modules object,\n/******/ \t\t// then flag all "chunkIds" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n/******/ \t\t\t\tvar _m = moreModules[moduleId];\n/******/\n/******/ \t\t\t\t// Check if module is deduplicated\n/******/ \t\t\t\tswitch(typeof _m) {\n/******/ \t\t\t\tcase "object":\n/******/ \t\t\t\t\t// Module can be created from a template\n/******/ \t\t\t\t\tmodules[moduleId] = (function(_m) {\n/******/ \t\t\t\t\t\tvar args = _m.slice(1), templateId = _m[0];\n/******/ \t\t\t\t\t\treturn function (a,b,c) {\n/******/ \t\t\t\t\t\t\tmodules[templateId].apply(this, [a,b,c].concat(args));\n/******/ \t\t\t\t\t\t};\n/******/ \t\t\t\t\t}(_m));\n/******/ \t\t\t\t\tbreak;\n/******/ \t\t\t\tcase "function":\n/******/ \t\t\t\t\t// Normal module\n/******/ \t\t\t\t\tmodules[moduleId] = _m;\n/******/ \t\t\t\t\tbreak;\n/******/ \t\t\t\tdefault:\n/******/ \t\t\t\t\t// Module is a copy of another module\n/******/ \t\t\t\t\tmodules[moduleId] = modules[_m];\n/******/ \t\t\t\t\tbreak;\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// "0" means "already loaded"\n/******/ \t// Array means "loading", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t1:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// "0" is the signal for "already loaded"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means "currently loading".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName(\'head\')[0];\n/******/ \t\t\tvar script = document.createElement(\'script\');\n/******/ \t\t\tscript.type = \'text/javascript\';\n/******/ \t\t\tscript.charset = \'utf-8\';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + "" + ({"2":"js/spx-main","3":"js/spx-extractor","4":"js/spx-engagement","5":"js/SW-12345678-IAB_TEST","6":"js/SW-17524639-SERMO","7":"js/SW-17524777-1","8":"js/SW-17524777-2","9":"js/SW-23171363-1","10":"js/SW-23171363-10","11":"js/SW-23171363-11","12":"js/SW-23171363-12","13":"js/SW-23171363-13","14":"js/SW-23171363-14","15":"js/SW-23171363-15","16":"js/SW-23171363-16","17":"js/SW-23171363-17","18":"js/SW-23171363-18","19":"js/SW-23171363-19","20":"js/SW-23171363-2","21":"js/SW-23171363-20","22":"js/SW-23171363-21","23":"js/SW-23171363-22","24":"js/SW-23171363-3","25":"js/SW-23171363-33","26":"js/SW-23171363-4","27":"js/SW-23171363-5","28":"js/SW-23171363-6","29":"js/SW-23171363-7","30":"js/SW-23171363-8","31":"js/SW-23171363-9","32":"js/SW-59153175-2","33":"js/SW-84350843-5T","34":"js/SW-84350843-6T","35":"js/SW-84784694-27"}[chunkId]||chunkId) + "." + "ad5ede308a113a3aac71" + ".js";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "https://client-deploy.swpcld.com/";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase "function": break;\n\t\t\tcase "object":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ }),\n/* 1 */,\n/* 2 */,\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t  \'use strict\';\n\t\n\t  var Bootstrap = __webpack_require__(4);\n\t  var utils = __webpack_require__(11);\n\t\n\t  try {\n\t    new Bootstrap(window, window.parent, window.top).boot();\n\t  } catch (err) {\n\t    // TODO throw e/boot event\n\t    utils.log(err);\n\t  }\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {\n\t  \'use strict\';\n\t\n\t  var RSVP = __webpack_require__(5);\n\t  var utils = __webpack_require__(11);\n\t  var Identity = __webpack_require__(12);\n\t\n\t  var SERVICES_ENDPOINT = (\'https://www.swpsvc.com\');\n\t  var CDN_ENDPOINT = (\'https://client-deploy.swpcld.com\');\n\t  var ARDRONE_ENDPOINT = (\'https://ardrone.swoop.com\');\n\t  var LIVERAMP_ENDPOINT = (\'https://api.rlcdn.com\');\n\t  var JQUERY_CDN_PATH = (\'https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\');\n\t\n\t  var NON_PRODUCTION_USER = \'test\';\n\t\n\t  function Bootstrap(spxIframeWindow, spxwScriptWindow, hostWindow) {\n\t    this._spxIframeWindow = spxIframeWindow;\n\t    this._spxwScriptWindow = spxwScriptWindow;\n\t    this._hostWindow = hostWindow;\n\t\n\t    this._scriptEle = this._findOwnScript();\n\t\n\t    this._isBookmarklet = this._spxIframeWindow.isBookmarklet === \'1\';\n\t\n\t    this._settings = {};\n\t  }\n\t\n\t  Bootstrap.prototype.boot = function() {\n\t    var me = this;\n\t    this._setWebpackPublicPath();\n\t    this._envCheck();\n\t    this._addPrefetch();\n\t    this._resolveScriptSettings();\n\t    var cleanedPageUrl = this._resolveUrlSettings();\n\t    this._setupSPX();\n\t\n\t    var bootPromise = this._requestBoot(cleanedPageUrl);\n\t    var jQueryPromise = this._loadJQuery();\n\t    // Start identity loading NOTE: in future we may wait on this here so the IDs are available to the backend\n\t    Identity.initialize(this._settings.domain);\n\t\n\t    var bootstrapDeferred = RSVP.defer();\n\t    // Load spx-main chunk\n\t    __webpack_require__.e/* nsure */(2, function(require) {\n\t      var spxMain = __webpack_require__(15);\n\t\n\t      // Load a plugin if one is defined for the domain\n\t      var pluginPromise = RSVP.resolve(null);\n\t      try {\n\t        // This will throw if there is no plugin defined for this domain id\n\t        var pluginLoader = __webpack_require__(268)("./" + me._settings.domain);\n\t\n\t        pluginPromise = new RSVP.Promise(function(resolve) {\n\t          pluginLoader(function(Plugin) {\n\t            resolve(Plugin);\n\t          });\n\t        });\n\t      } catch (e) { /* There is no custom plugin */ }\n\t\n\t      RSVP.hash({\n\t        jQuery: jQueryPromise,\n\t        boot: bootPromise,\n\t        Plugin: pluginPromise\n\t      }).then(function(results) {\n\t        spxMain.run(results.Plugin);\n\t        bootstrapDeferred.resolve();\n\t      }).catch(function(err) {\n\t        function isHaltError(e) {\n\t          return e != null && typeof e === \'object\' && e.topic === \'halt\';\n\t        }\n\t\n\t        if (!isHaltError(err)) {\n\t          utils.bootError(cleanedPageUrl, me._settings.domain, [\'web-sdk boot failure\', err]);\n\t          utils.log(err);\n\t        }\n\t\n\t        bootstrapDeferred.reject();\n\t      });\n\t    });\n\t\n\t    return bootstrapDeferred.promise;\n\t  };\n\t\n\t  // Allows overriding the webpack publicPath set during the build\n\t  // This is only used in integration testing to allow testing the production build\n\t  Bootstrap.prototype._setWebpackPublicPath = function() {\n\t    var publicPathOverride = this._scriptEle.getAttribute(\'data-override-publicPath\');\n\t    if (publicPathOverride) {\n\t      __webpack_require__.p = publicPathOverride;\n\t    }\n\t  };\n\t\n\t  Bootstrap.prototype._envCheck = function() {\n\t    var ua = this._hostWindow.navigator.userAgent;\n\t\n\t    function userAgentVersionLessThan(re, min) {\n\t      return re.exec(ua) && parseFloat(RegExp.$1) < min;\n\t    }\n\t\n\t    if (!this._spxIframeWindow.JSON || (typeof this._spxIframeWindow.JSON.stringify !== \'function\')) utils.throw(\'JSON\');\n\t    if (userAgentVersionLessThan(/MSIE (\\d+)/i, 9) || userAgentVersionLessThan(/Firefox[\\/\\s](\\d+)/i, 4)) utils.throw(\'UA:\' + ua);\n\t    if ((/DartIFrame.html/i).test(this._spxwScriptWindow.location.href)) utils.throw(\'Dart\');\n\t  };\n\t\n\t  Bootstrap.prototype._loadJQuery = function() {\n\t    var me = this;\n\t    // In production load jquery async from CDN, in dev it will come from libs.\n\t    if (true) {\n\t      return utils.loadJavascript(me._spxIframeWindow.document, JQUERY_CDN_PATH);\n\t    } else {\n\t      return RSVP.resolve();\n\t    }\n\t  };\n\t\n\t  Bootstrap.prototype._requestBoot = function(pageUrl) {\n\t    var me = this;\n\t\n\t    return new RSVP.Promise(function(resolve, reject) {\n\t      // This is a hack to get a handle to a \'halt\' response from spxBoot which currently calls SPX.error\n\t      // TODO need to rework the spxBoot API\n\t      me._onError = reject;\n\t\n\t      // Invoke JS script, expecting it to invoke SPX functions.\n\t      utils.loadJavascript(me._spxIframeWindow.document,\n\t        utils.composeUrl(me._settings.serverBase + \'/s/js/spxboot.js\', {\n\t          d: me._settings.domain,\n\t          h: pageUrl,\n\t          u: me._settings.user,\n\t          swtags: me._settings.swtags\n\t        })\n\t      ).then(resolve, reject);\n\t    });\n\t  };\n\t\n\t  Bootstrap.prototype._addPrefetch = function() {\n\t    var doc = this._hostWindow.document;\n\t    var head = doc.head;\n\t\n\t    // It may be possible in a wonky integration that the HEAD element isn\'t available yet\n\t    // Defend against this situation as these prefetch tags are non critical.\n\t    if (head) {\n\t      head.appendChild(utils.buildLinkElement(doc, \'preconnect\', SERVICES_ENDPOINT, true));\n\t      head.appendChild(utils.buildLinkElement(doc, \'preconnect\', CDN_ENDPOINT));\n\t      head.appendChild(utils.buildLinkElement(doc, \'preconnect\', ARDRONE_ENDPOINT));\n\t      head.appendChild(utils.buildLinkElement(doc, \'preconnect\', LIVERAMP_ENDPOINT));\n\t\n\t      // Preconnect is not currently supported by Safari, IE or Edge but dns-prefetch is\n\t      head.appendChild(utils.buildLinkElement(doc, \'dns-prefetch\', SERVICES_ENDPOINT));\n\t      head.appendChild(utils.buildLinkElement(doc, \'dns-prefetch\', CDN_ENDPOINT));\n\t      head.appendChild(utils.buildLinkElement(doc, \'dns-prefetch\', LIVERAMP_ENDPOINT));\n\t    }\n\t  };\n\t\n\t  Bootstrap.prototype._setupSPX = function() {\n\t    var me = this;\n\t\n\t    // Initialize the SPX object.  If already present (and we\'re not the bookmarklet), abort.\n\t    if (this._hostWindow.SPX && !this._isBookmarklet && me._settings.domain !== \'SW-84784694-9\') {\n\t      utils.throw(\'multi\');\n\t    }\n\t\n\t    this._spxIframeWindow.SPX = this._spxwScriptWindow.SPX = {\n\t      epoch: new Date().getTime(),\n\t      isReady: false,\n\t      oldSPX: this._spxwScriptWindow.SPX,    // bookmarklet support\n\t      _settings: me._settings,  // make settings available to next stage\n\t\n\t      trace: utils.trace,\n\t      log: utils.log,\n\t      throw: utils.throw,\n\t\n\t      // spxboot callback: update settings\n\t      xs: function(newSettings) {\n\t        if (newSettings) {\n\t          for (var key in newSettings) {\n\t            // @todo this overrides; should it merge instead?\n\t            me._settings[key] = newSettings[key];\n\t          }\n\t        }\n\t        return me._settings;\n\t      },\n\t\n\t      // NOOP - leaving here temporarily during the deploy to avoid console errors\n\t      // TODO Remove as soon as call is removed from spxBoot response\n\t      go: function() {},\n\t\n\t      // spxboot callback: stops processing by nature of not loading a next step\n\t      error: function(res) {\n\t        me._spxIframeWindow.SPX.errorReason = res;\n\t        utils.trace(\'SPX.error\', res);\n\t        // log stop instead of error for publishers\' & users\' sakes; less threatening\n\t        utils.log(\'SPX stop\');\n\t\n\t        // This is a hack to get a handle to a \'halt\' response from spxBoot which currently calls SPX.error\n\t        // TODO need to rework the spxBoot API\n\t        if (me._onError) me._onError(res);\n\t      }\n\t    };\n\t\n\t  };\n\t\n\t  Bootstrap.prototype._findOwnScript = function() {\n\t    var spxwScripts = utils.findSpxwScripts(this._spxwScriptWindow.document);\n\t\n\t    if (spxwScripts.length === 0) {\n\t      utils.throw(\'no script\');\n\t    }\n\t\n\t    // TODO this returns the last spxw script tag due to an implicit assumption about how the bookmarklet functions\n\t    return spxwScripts[spxwScripts.length - 1];\n\t  };\n\t\n\t  Bootstrap.prototype._resolveScriptSettings = function() {\n\t    this._settings.serverBase = this._scriptEle.getAttribute(\'data-override-serverBase\') || SERVICES_ENDPOINT;\n\t\n\t    // TODO should be support other options here?\n\t    for (var key in { user: 1, domain: 1, swtags: 1 }) {\n\t      this._settings[key] = this._scriptEle.getAttribute(\'data-\' + key);\n\t    }\n\t\n\t    if (this._scriptEle.hasAttribute(\'data-publisher\')) {\n\t      var pub;\n\t\n\t      try {\n\t        pub = JSON.parse(this._scriptEle.getAttribute(\'data-publisher\'));\n\t      } catch (err) {\n\t        utils.log(err);\n\t        pub = {};\n\t      }\n\t\n\t      for (var k in pub) {\n\t        if (pub.hasOwnProperty(k)) {\n\t          this._settings[k] = pub[k];\n\t        }\n\t      }\n\t    }\n\t\n\t  };\n\t\n\t  // Extract url param settings and place them in `settings`\n\t  // Returns the url with these params removed\n\t  Bootstrap.prototype._resolveUrlSettings = function() {\n\t    var result = utils.extractSPXParams(this._hostWindow.location.href);\n\t\n\t    this._settings.urlSettings = this._settings.urlSettings || {};\n\t\n\t    if (Object.keys(result.params).length) {\n\t      for (var key in result.params) {\n\t        this._settings.urlSettings[key] = result.params[key];\n\t      }\n\t\n\t      // If any spx params are found, mark ourselves as non-production traffic\n\t      this._settings.user = this._settings.user || NON_PRODUCTION_USER;\n\t    }\n\t\n\t    return result.url;\n\t  };\n\t\n\t\n\t  return Bootstrap;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, global, module) {/*!\n\t * @overview RSVP - a tiny implementation of Promises/A+.\n\t * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors\n\t * @license   Licensed under MIT license\n\t *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE\n\t * @version   3.0.18\n\t */\n\t\n\t(function() {\n\t    "use strict";\n\t    function lib$rsvp$utils$$objectOrFunction(x) {\n\t      return typeof x === \'function\' || (typeof x === \'object\' && x !== null);\n\t    }\n\t\n\t    function lib$rsvp$utils$$isFunction(x) {\n\t      return typeof x === \'function\';\n\t    }\n\t\n\t    function lib$rsvp$utils$$isMaybeThenable(x) {\n\t      return typeof x === \'object\' && x !== null;\n\t    }\n\t\n\t    var lib$rsvp$utils$$_isArray;\n\t    if (!Array.isArray) {\n\t      lib$rsvp$utils$$_isArray = function (x) {\n\t        return Object.prototype.toString.call(x) === \'[object Array]\';\n\t      };\n\t    } else {\n\t      lib$rsvp$utils$$_isArray = Array.isArray;\n\t    }\n\t\n\t    var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;\n\t\n\t    var lib$rsvp$utils$$now = Date.now || function() { return new Date().getTime(); };\n\t\n\t    function lib$rsvp$utils$$F() { }\n\t\n\t    var lib$rsvp$utils$$o_create = (Object.create || function (o) {\n\t      if (arguments.length > 1) {\n\t        throw new Error(\'Second argument not supported\');\n\t      }\n\t      if (typeof o !== \'object\') {\n\t        throw new TypeError(\'Argument must be an object\');\n\t      }\n\t      lib$rsvp$utils$$F.prototype = o;\n\t      return new lib$rsvp$utils$$F();\n\t    });\n\t    function lib$rsvp$events$$indexOf(callbacks, callback) {\n\t      for (var i=0, l=callbacks.length; i<l; i++) {\n\t        if (callbacks[i] === callback) { return i; }\n\t      }\n\t\n\t      return -1;\n\t    }\n\t\n\t    function lib$rsvp$events$$callbacksFor(object) {\n\t      var callbacks = object._promiseCallbacks;\n\t\n\t      if (!callbacks) {\n\t        callbacks = object._promiseCallbacks = {};\n\t      }\n\t\n\t      return callbacks;\n\t    }\n\t\n\t    var lib$rsvp$events$$default = {\n\t\n\t      /**\n\t        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For\n\t        Example:\n\t\n\t        ```javascript\n\t        var object = {};\n\t\n\t        RSVP.EventTarget.mixin(object);\n\t\n\t        object.on(\'finished\', function(event) {\n\t          // handle event\n\t        });\n\t\n\t        object.trigger(\'finished\', { detail: value });\n\t        ```\n\t\n\t        `EventTarget.mixin` also works with prototypes:\n\t\n\t        ```javascript\n\t        var Person = function() {};\n\t        RSVP.EventTarget.mixin(Person.prototype);\n\t\n\t        var yehuda = new Person();\n\t        var tom = new Person();\n\t\n\t        yehuda.on(\'poke\', function(event) {\n\t          console.log(\'Yehuda says OW\');\n\t        });\n\t\n\t        tom.on(\'poke\', function(event) {\n\t          console.log(\'Tom says OW\');\n\t        });\n\t\n\t        yehuda.trigger(\'poke\');\n\t        tom.trigger(\'poke\');\n\t        ```\n\t\n\t        @method mixin\n\t        @for RSVP.EventTarget\n\t        @private\n\t        @param {Object} object object to extend with EventTarget methods\n\t      */\n\t      \'mixin\': function(object) {\n\t        object[\'on\']      = this[\'on\'];\n\t        object[\'off\']     = this[\'off\'];\n\t        object[\'trigger\'] = this[\'trigger\'];\n\t        object._promiseCallbacks = undefined;\n\t        return object;\n\t      },\n\t\n\t      /**\n\t        Registers a callback to be executed when `eventName` is triggered\n\t\n\t        ```javascript\n\t        object.on(\'event\', function(eventInfo){\n\t          // handle the event\n\t        });\n\t\n\t        object.trigger(\'event\');\n\t        ```\n\t\n\t        @method on\n\t        @for RSVP.EventTarget\n\t        @private\n\t        @param {String} eventName name of the event to listen for\n\t        @param {Function} callback function to be called when the event is triggered.\n\t      */\n\t      \'on\': function(eventName, callback) {\n\t        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks;\n\t\n\t        callbacks = allCallbacks[eventName];\n\t\n\t        if (!callbacks) {\n\t          callbacks = allCallbacks[eventName] = [];\n\t        }\n\t\n\t        if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {\n\t          callbacks.push(callback);\n\t        }\n\t      },\n\t\n\t      /**\n\t        You can use `off` to stop firing a particular callback for an event:\n\t\n\t        ```javascript\n\t        function doStuff() { // do stuff! }\n\t        object.on(\'stuff\', doStuff);\n\t\n\t        object.trigger(\'stuff\'); // doStuff will be called\n\t\n\t        // Unregister ONLY the doStuff callback\n\t        object.off(\'stuff\', doStuff);\n\t        object.trigger(\'stuff\'); // doStuff will NOT be called\n\t        ```\n\t\n\t        If you don\'t pass a `callback` argument to `off`, ALL callbacks for the\n\t        event will not be executed when the event fires. For example:\n\t\n\t        ```javascript\n\t        var callback1 = function(){};\n\t        var callback2 = function(){};\n\t\n\t        object.on(\'stuff\', callback1);\n\t        object.on(\'stuff\', callback2);\n\t\n\t        object.trigger(\'stuff\'); // callback1 and callback2 will be executed.\n\t\n\t        object.off(\'stuff\');\n\t        object.trigger(\'stuff\'); // callback1 and callback2 will not be executed!\n\t        ```\n\t\n\t        @method off\n\t        @for RSVP.EventTarget\n\t        @private\n\t        @param {String} eventName event to stop listening to\n\t        @param {Function} callback optional argument. If given, only the function\n\t        given will be removed from the event\'s callback queue. If no `callback`\n\t        argument is given, all callbacks will be removed from the event\'s callback\n\t        queue.\n\t      */\n\t      \'off\': function(eventName, callback) {\n\t        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, index;\n\t\n\t        if (!callback) {\n\t          allCallbacks[eventName] = [];\n\t          return;\n\t        }\n\t\n\t        callbacks = allCallbacks[eventName];\n\t\n\t        index = lib$rsvp$events$$indexOf(callbacks, callback);\n\t\n\t        if (index !== -1) { callbacks.splice(index, 1); }\n\t      },\n\t\n\t      /**\n\t        Use `trigger` to fire custom events. For example:\n\t\n\t        ```javascript\n\t        object.on(\'foo\', function(){\n\t          console.log(\'foo event happened!\');\n\t        });\n\t        object.trigger(\'foo\');\n\t        // \'foo event happened!\' logged to the console\n\t        ```\n\t\n\t        You can also pass a value as a second argument to `trigger` that will be\n\t        passed as an argument to all event listeners for the event:\n\t\n\t        ```javascript\n\t        object.on(\'foo\', function(value){\n\t          console.log(value.name);\n\t        });\n\t\n\t        object.trigger(\'foo\', { name: \'bar\' });\n\t        // \'bar\' logged to the console\n\t        ```\n\t\n\t        @method trigger\n\t        @for RSVP.EventTarget\n\t        @private\n\t        @param {String} eventName name of the event to be triggered\n\t        @param {Any} options optional value to be passed to any event handlers for\n\t        the given `eventName`\n\t      */\n\t      \'trigger\': function(eventName, options) {\n\t        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, callback;\n\t\n\t        if (callbacks = allCallbacks[eventName]) {\n\t          // Don\'t cache the callbacks.length since it may grow\n\t          for (var i=0; i<callbacks.length; i++) {\n\t            callback = callbacks[i];\n\t\n\t            callback(options);\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    var lib$rsvp$config$$config = {\n\t      instrument: false\n\t    };\n\t\n\t    lib$rsvp$events$$default[\'mixin\'](lib$rsvp$config$$config);\n\t\n\t    function lib$rsvp$config$$configure(name, value) {\n\t      if (name === \'onerror\') {\n\t        // handle for legacy users that expect the actual\n\t        // error to be passed to their function added via\n\t        // `RSVP.configure(\'onerror\', someFunctionHere);`\n\t        lib$rsvp$config$$config[\'on\'](\'error\', value);\n\t        return;\n\t      }\n\t\n\t      if (arguments.length === 2) {\n\t        lib$rsvp$config$$config[name] = value;\n\t      } else {\n\t        return lib$rsvp$config$$config[name];\n\t      }\n\t    }\n\t\n\t    var lib$rsvp$instrument$$queue = [];\n\t\n\t    function lib$rsvp$instrument$$scheduleFlush() {\n\t      setTimeout(function() {\n\t        var entry;\n\t        for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {\n\t          entry = lib$rsvp$instrument$$queue[i];\n\t\n\t          var payload = entry.payload;\n\t\n\t          payload.guid = payload.key + payload.id;\n\t          payload.childGuid = payload.key + payload.childId;\n\t          if (payload.error) {\n\t            payload.stack = payload.error.stack;\n\t          }\n\t\n\t          lib$rsvp$config$$config[\'trigger\'](entry.name, entry.payload);\n\t        }\n\t        lib$rsvp$instrument$$queue.length = 0;\n\t      }, 50);\n\t    }\n\t\n\t    function lib$rsvp$instrument$$instrument(eventName, promise, child) {\n\t      if (1 === lib$rsvp$instrument$$queue.push({\n\t        name: eventName,\n\t        payload: {\n\t          key: promise._guidKey,\n\t          id:  promise._id,\n\t          eventName: eventName,\n\t          detail: promise._result,\n\t          childId: child && child._id,\n\t          label: promise._label,\n\t          timeStamp: lib$rsvp$utils$$now(),\n\t          error: lib$rsvp$config$$config["instrument-with-stack"] ? new Error(promise._label) : null\n\t        }})) {\n\t          lib$rsvp$instrument$$scheduleFlush();\n\t        }\n\t      }\n\t    var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;\n\t\n\t    function  lib$rsvp$$internal$$withOwnPromise() {\n\t      return new TypeError(\'A promises callback cannot return that same promise.\');\n\t    }\n\t\n\t    function lib$rsvp$$internal$$noop() {}\n\t\n\t    var lib$rsvp$$internal$$PENDING   = void 0;\n\t    var lib$rsvp$$internal$$FULFILLED = 1;\n\t    var lib$rsvp$$internal$$REJECTED  = 2;\n\t\n\t    var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();\n\t\n\t    function lib$rsvp$$internal$$getThen(promise) {\n\t      try {\n\t        return promise.then;\n\t      } catch(error) {\n\t        lib$rsvp$$internal$$GET_THEN_ERROR.error = error;\n\t        return lib$rsvp$$internal$$GET_THEN_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n\t      try {\n\t        then.call(value, fulfillmentHandler, rejectionHandler);\n\t      } catch(e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {\n\t      lib$rsvp$config$$config.async(function(promise) {\n\t        var sealed = false;\n\t        var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t          if (thenable !== value) {\n\t            lib$rsvp$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$rsvp$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t\n\t          lib$rsvp$$internal$$reject(promise, reason);\n\t        }, \'Settle: \' + (promise._label || \' unknown promise\'));\n\t\n\t        if (!sealed && error) {\n\t          sealed = true;\n\t          lib$rsvp$$internal$$reject(promise, error);\n\t        }\n\t      }, promise);\n\t    }\n\t\n\t    function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {\n\t      if (thenable._state === lib$rsvp$$internal$$FULFILLED) {\n\t        lib$rsvp$$internal$$fulfill(promise, thenable._result);\n\t      } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {\n\t        thenable._onError = null;\n\t        lib$rsvp$$internal$$reject(promise, thenable._result);\n\t      } else {\n\t        lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {\n\t          if (thenable !== value) {\n\t            lib$rsvp$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$rsvp$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          lib$rsvp$$internal$$reject(promise, reason);\n\t        });\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {\n\t      if (maybeThenable.constructor === promise.constructor) {\n\t        lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);\n\t      } else {\n\t        var then = lib$rsvp$$internal$$getThen(maybeThenable);\n\t\n\t        if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {\n\t          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);\n\t        } else if (then === undefined) {\n\t          lib$rsvp$$internal$$fulfill(promise, maybeThenable);\n\t        } else if (lib$rsvp$utils$$isFunction(then)) {\n\t          lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);\n\t        } else {\n\t          lib$rsvp$$internal$$fulfill(promise, maybeThenable);\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$$internal$$resolve(promise, value) {\n\t      if (promise === value) {\n\t        lib$rsvp$$internal$$fulfill(promise, value);\n\t      } else if (lib$rsvp$utils$$objectOrFunction(value)) {\n\t        lib$rsvp$$internal$$handleMaybeThenable(promise, value);\n\t      } else {\n\t        lib$rsvp$$internal$$fulfill(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$$internal$$publishRejection(promise) {\n\t      if (promise._onError) {\n\t        promise._onError(promise._result);\n\t      }\n\t\n\t      lib$rsvp$$internal$$publish(promise);\n\t    }\n\t\n\t    function lib$rsvp$$internal$$fulfill(promise, value) {\n\t      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }\n\t\n\t      promise._result = value;\n\t      promise._state = lib$rsvp$$internal$$FULFILLED;\n\t\n\t      if (promise._subscribers.length === 0) {\n\t        if (lib$rsvp$config$$config.instrument) {\n\t          lib$rsvp$instrument$$default(\'fulfilled\', promise);\n\t        }\n\t      } else {\n\t        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$$internal$$reject(promise, reason) {\n\t      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }\n\t      promise._state = lib$rsvp$$internal$$REJECTED;\n\t      promise._result = reason;\n\t      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);\n\t    }\n\t\n\t    function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n\t      var subscribers = parent._subscribers;\n\t      var length = subscribers.length;\n\t\n\t      parent._onError = null;\n\t\n\t      subscribers[length] = child;\n\t      subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;\n\t      subscribers[length + lib$rsvp$$internal$$REJECTED]  = onRejection;\n\t\n\t      if (length === 0 && parent._state) {\n\t        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$$internal$$publish(promise) {\n\t      var subscribers = promise._subscribers;\n\t      var settled = promise._state;\n\t\n\t      if (lib$rsvp$config$$config.instrument) {\n\t        lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? \'fulfilled\' : \'rejected\', promise);\n\t      }\n\t\n\t      if (subscribers.length === 0) { return; }\n\t\n\t      var child, callback, detail = promise._result;\n\t\n\t      for (var i = 0; i < subscribers.length; i += 3) {\n\t        child = subscribers[i];\n\t        callback = subscribers[i + settled];\n\t\n\t        if (child) {\n\t          lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);\n\t        } else {\n\t          callback(detail);\n\t        }\n\t      }\n\t\n\t      promise._subscribers.length = 0;\n\t    }\n\t\n\t    function lib$rsvp$$internal$$ErrorObject() {\n\t      this.error = null;\n\t    }\n\t\n\t    var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();\n\t\n\t    function lib$rsvp$$internal$$tryCatch(callback, detail) {\n\t      try {\n\t        return callback(detail);\n\t      } catch(e) {\n\t        lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;\n\t        return lib$rsvp$$internal$$TRY_CATCH_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {\n\t      var hasCallback = lib$rsvp$utils$$isFunction(callback),\n\t          value, error, succeeded, failed;\n\t\n\t      if (hasCallback) {\n\t        value = lib$rsvp$$internal$$tryCatch(callback, detail);\n\t\n\t        if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {\n\t          failed = true;\n\t          error = value.error;\n\t          value = null;\n\t        } else {\n\t          succeeded = true;\n\t        }\n\t\n\t        if (promise === value) {\n\t          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());\n\t          return;\n\t        }\n\t\n\t      } else {\n\t        value = detail;\n\t        succeeded = true;\n\t      }\n\t\n\t      if (promise._state !== lib$rsvp$$internal$$PENDING) {\n\t        // noop\n\t      } else if (hasCallback && succeeded) {\n\t        lib$rsvp$$internal$$resolve(promise, value);\n\t      } else if (failed) {\n\t        lib$rsvp$$internal$$reject(promise, error);\n\t      } else if (settled === lib$rsvp$$internal$$FULFILLED) {\n\t        lib$rsvp$$internal$$fulfill(promise, value);\n\t      } else if (settled === lib$rsvp$$internal$$REJECTED) {\n\t        lib$rsvp$$internal$$reject(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$$internal$$initializePromise(promise, resolver) {\n\t      var resolved = false;\n\t      try {\n\t        resolver(function resolvePromise(value){\n\t          if (resolved) { return; }\n\t          resolved = true;\n\t          lib$rsvp$$internal$$resolve(promise, value);\n\t        }, function rejectPromise(reason) {\n\t          if (resolved) { return; }\n\t          resolved = true;\n\t          lib$rsvp$$internal$$reject(promise, reason);\n\t        });\n\t      } catch(e) {\n\t        lib$rsvp$$internal$$reject(promise, e);\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {\n\t      if (state === lib$rsvp$$internal$$FULFILLED) {\n\t        return {\n\t          state: \'fulfilled\',\n\t          value: value\n\t        };\n\t      } else {\n\t         return {\n\t          state: \'rejected\',\n\t          reason: value\n\t        };\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\n\t      var enumerator = this;\n\t\n\t      enumerator._instanceConstructor = Constructor;\n\t      enumerator.promise = new Constructor(lib$rsvp$$internal$$noop, label);\n\t      enumerator._abortOnReject = abortOnReject;\n\t\n\t      if (enumerator._validateInput(input)) {\n\t        enumerator._input     = input;\n\t        enumerator.length     = input.length;\n\t        enumerator._remaining = input.length;\n\t\n\t        enumerator._init();\n\t\n\t        if (enumerator.length === 0) {\n\t          lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t        } else {\n\t          enumerator.length = enumerator.length || 0;\n\t          enumerator._enumerate();\n\t          if (enumerator._remaining === 0) {\n\t            lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);\n\t          }\n\t        }\n\t      } else {\n\t        lib$rsvp$$internal$$reject(enumerator.promise, enumerator._validationError());\n\t      }\n\t    }\n\t\n\t    var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;\n\t\n\t    lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {\n\t      return lib$rsvp$utils$$isArray(input);\n\t    };\n\t\n\t    lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {\n\t      return new Error(\'Array Methods must be provided an Array\');\n\t    };\n\t\n\t    lib$rsvp$enumerator$$Enumerator.prototype._init = function() {\n\t      this._result = new Array(this.length);\n\t    };\n\t\n\t    lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {\n\t      var enumerator = this;\n\t      var length     = enumerator.length;\n\t      var promise    = enumerator.promise;\n\t      var input      = enumerator._input;\n\t\n\t      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n\t        enumerator._eachEntry(input[i], i);\n\t      }\n\t    };\n\t\n\t    lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n\t      var enumerator = this;\n\t      var c = enumerator._instanceConstructor;\n\t      if (lib$rsvp$utils$$isMaybeThenable(entry)) {\n\t        if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {\n\t          entry._onError = null;\n\t          enumerator._settledAt(entry._state, i, entry._result);\n\t        } else {\n\t          enumerator._willSettleAt(c.resolve(entry), i);\n\t        }\n\t      } else {\n\t        enumerator._remaining--;\n\t        enumerator._result[i] = enumerator._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);\n\t      }\n\t    };\n\t\n\t    lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n\t      var enumerator = this;\n\t      var promise = enumerator.promise;\n\t\n\t      if (promise._state === lib$rsvp$$internal$$PENDING) {\n\t        enumerator._remaining--;\n\t\n\t        if (enumerator._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {\n\t          lib$rsvp$$internal$$reject(promise, value);\n\t        } else {\n\t          enumerator._result[i] = enumerator._makeResult(state, i, value);\n\t        }\n\t      }\n\t\n\t      if (enumerator._remaining === 0) {\n\t        lib$rsvp$$internal$$fulfill(promise, enumerator._result);\n\t      }\n\t    };\n\t\n\t    lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\n\t      return value;\n\t    };\n\t\n\t    lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n\t      var enumerator = this;\n\t\n\t      lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {\n\t        enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);\n\t      }, function(reason) {\n\t        enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);\n\t      });\n\t    };\n\t    function lib$rsvp$promise$all$$all(entries, label) {\n\t      return new lib$rsvp$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\n\t    }\n\t    var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;\n\t    function lib$rsvp$promise$race$$race(entries, label) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n\t\n\t      if (!lib$rsvp$utils$$isArray(entries)) {\n\t        lib$rsvp$$internal$$reject(promise, new TypeError(\'You must pass an array to race.\'));\n\t        return promise;\n\t      }\n\t\n\t      var length = entries.length;\n\t\n\t      function onFulfillment(value) {\n\t        lib$rsvp$$internal$$resolve(promise, value);\n\t      }\n\t\n\t      function onRejection(reason) {\n\t        lib$rsvp$$internal$$reject(promise, reason);\n\t      }\n\t\n\t      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n\t        lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n\t      }\n\t\n\t      return promise;\n\t    }\n\t    var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;\n\t    function lib$rsvp$promise$resolve$$resolve(object, label) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (object && typeof object === \'object\' && object.constructor === Constructor) {\n\t        return object;\n\t      }\n\t\n\t      var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n\t      lib$rsvp$$internal$$resolve(promise, object);\n\t      return promise;\n\t    }\n\t    var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;\n\t    function lib$rsvp$promise$reject$$reject(reason, label) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t      var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n\t      lib$rsvp$$internal$$reject(promise, reason);\n\t      return promise;\n\t    }\n\t    var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;\n\t\n\t    var lib$rsvp$promise$$guidKey = \'rsvp_\' + lib$rsvp$utils$$now() + \'-\';\n\t    var lib$rsvp$promise$$counter = 0;\n\t\n\t    function lib$rsvp$promise$$needsResolver() {\n\t      throw new TypeError(\'You must pass a resolver function as the first argument to the promise constructor\');\n\t    }\n\t\n\t    function lib$rsvp$promise$$needsNew() {\n\t      throw new TypeError("Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.");\n\t    }\n\t\n\t    function lib$rsvp$promise$$Promise(resolver, label) {\n\t      var promise = this;\n\t\n\t      promise._id = lib$rsvp$promise$$counter++;\n\t      promise._label = label;\n\t      promise._state = undefined;\n\t      promise._result = undefined;\n\t      promise._subscribers = [];\n\t\n\t      if (lib$rsvp$config$$config.instrument) {\n\t        lib$rsvp$instrument$$default(\'created\', promise);\n\t      }\n\t\n\t      if (lib$rsvp$$internal$$noop !== resolver) {\n\t        if (!lib$rsvp$utils$$isFunction(resolver)) {\n\t          lib$rsvp$promise$$needsResolver();\n\t        }\n\t\n\t        if (!(promise instanceof lib$rsvp$promise$$Promise)) {\n\t          lib$rsvp$promise$$needsNew();\n\t        }\n\t\n\t        lib$rsvp$$internal$$initializePromise(promise, resolver);\n\t      }\n\t    }\n\t\n\t    var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;\n\t\n\t    // deprecated\n\t    lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;\n\t    lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;\n\t    lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;\n\t    lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;\n\t    lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;\n\t\n\t    lib$rsvp$promise$$Promise.prototype = {\n\t      constructor: lib$rsvp$promise$$Promise,\n\t\n\t      _guidKey: lib$rsvp$promise$$guidKey,\n\t\n\t      _onError: function (reason) {\n\t        lib$rsvp$config$$config.async(function(promise) {\n\t          setTimeout(function() {\n\t            if (promise._onError) {\n\t              lib$rsvp$config$$config[\'trigger\'](\'error\', reason);\n\t            }\n\t          }, 0);\n\t        }, this);\n\t      },\n\t\n\t    /**\n\t      The primary way of interacting with a promise is through its `then` method,\n\t      which registers callbacks to receive either a promise\'s eventual value or the\n\t      reason why the promise cannot be fulfilled.\n\t\n\t      ```js\n\t      findUser().then(function(user){\n\t        // user is available\n\t      }, function(reason){\n\t        // user is unavailable, and you are given the reason why\n\t      });\n\t      ```\n\t\n\t      Chaining\n\t      --------\n\t\n\t      The return value of `then` is itself a promise.  This second, \'downstream\'\n\t      promise is resolved with the return value of the first promise\'s fulfillment\n\t      or rejection handler, or rejected if the handler throws an exception.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return user.name;\n\t      }, function (reason) {\n\t        return \'default name\';\n\t      }).then(function (userName) {\n\t        // If `findUser` fulfilled, `userName` will be the user\'s name, otherwise it\n\t        // will be `\'default name\'`\n\t      });\n\t\n\t      findUser().then(function (user) {\n\t        throw new Error(\'Found user, but still unhappy\');\n\t      }, function (reason) {\n\t        throw new Error(\'`findUser` rejected and we\'re unhappy\');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // if `findUser` fulfilled, `reason` will be \'Found user, but still unhappy\'.\n\t        // If `findUser` rejected, `reason` will be \'`findUser` rejected and we\'re unhappy\'.\n\t      });\n\t      ```\n\t      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        throw new PedagogicalException(\'Upstream error\');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // The `PedgagocialException` is propagated all the way down to here\n\t      });\n\t      ```\n\t\n\t      Assimilation\n\t      ------------\n\t\n\t      Sometimes the value you want to propagate to a downstream promise can only be\n\t      retrieved asynchronously. This can be achieved by returning a promise in the\n\t      fulfillment or rejection handler. The downstream promise will then be pending\n\t      until the returned promise is settled. This is called *assimilation*.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // The user\'s comments are now available\n\t      });\n\t      ```\n\t\n\t      If the assimliated promise rejects, then the downstream promise will also reject.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // If `findCommentsByAuthor` fulfills, we\'ll have the value here\n\t      }, function (reason) {\n\t        // If `findCommentsByAuthor` rejects, we\'ll have the reason here\n\t      });\n\t      ```\n\t\n\t      Simple Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var result;\n\t\n\t      try {\n\t        result = findResult();\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t      findResult(function(result, err){\n\t        if (err) {\n\t          // failure\n\t        } else {\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findResult().then(function(result){\n\t        // success\n\t      }, function(reason){\n\t        // failure\n\t      });\n\t      ```\n\t\n\t      Advanced Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var author, books;\n\t\n\t      try {\n\t        author = findAuthor();\n\t        books  = findBooksByAuthor(author);\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t\n\t      function foundBooks(books) {\n\t\n\t      }\n\t\n\t      function failure(reason) {\n\t\n\t      }\n\t\n\t      findAuthor(function(author, err){\n\t        if (err) {\n\t          failure(err);\n\t          // failure\n\t        } else {\n\t          try {\n\t            findBoooksByAuthor(author, function(books, err) {\n\t              if (err) {\n\t                failure(err);\n\t              } else {\n\t                try {\n\t                  foundBooks(books);\n\t                } catch(reason) {\n\t                  failure(reason);\n\t                }\n\t              }\n\t            });\n\t          } catch(error) {\n\t            failure(err);\n\t          }\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findAuthor().\n\t        then(findBooksByAuthor).\n\t        then(function(books){\n\t          // found books\n\t      }).catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method then\n\t      @param {Function} onFulfilled\n\t      @param {Function} onRejected\n\t      @param {String} label optional string for labeling the promise.\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      then: function(onFulfillment, onRejection, label) {\n\t        var parent = this;\n\t        var state = parent._state;\n\t\n\t        if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {\n\t          if (lib$rsvp$config$$config.instrument) {\n\t            lib$rsvp$instrument$$default(\'chained\', parent, parent);\n\t          }\n\t          return parent;\n\t        }\n\t\n\t        parent._onError = null;\n\t\n\t        var child = new parent.constructor(lib$rsvp$$internal$$noop, label);\n\t        var result = parent._result;\n\t\n\t        if (lib$rsvp$config$$config.instrument) {\n\t          lib$rsvp$instrument$$default(\'chained\', parent, child);\n\t        }\n\t\n\t        if (state) {\n\t          var callback = arguments[state - 1];\n\t          lib$rsvp$config$$config.async(function(){\n\t            lib$rsvp$$internal$$invokeCallback(state, child, callback, result);\n\t          });\n\t        } else {\n\t          lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n\t        }\n\t\n\t        return child;\n\t      },\n\t\n\t    /**\n\t      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n\t      as the catch block of a try/catch statement.\n\t\n\t      ```js\n\t      function findAuthor(){\n\t        throw new Error(\'couldn\'t find that author\');\n\t      }\n\t\n\t      // synchronous\n\t      try {\n\t        findAuthor();\n\t      } catch(reason) {\n\t        // something went wrong\n\t      }\n\t\n\t      // async with promises\n\t      findAuthor().catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method catch\n\t      @param {Function} onRejection\n\t      @param {String} label optional string for labeling the promise.\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      \'catch\': function(onRejection, label) {\n\t        return this.then(undefined, onRejection, label);\n\t      },\n\t\n\t    /**\n\t      `finally` will be invoked regardless of the promise\'s fate just as native\n\t      try/catch/finally behaves\n\t\n\t      Synchronous example:\n\t\n\t      ```js\n\t      findAuthor() {\n\t        if (Math.random() > 0.5) {\n\t          throw new Error();\n\t        }\n\t        return new Author();\n\t      }\n\t\n\t      try {\n\t        return findAuthor(); // succeed or fail\n\t      } catch(error) {\n\t        return findOtherAuther();\n\t      } finally {\n\t        // always runs\n\t        // doesn\'t affect the return value\n\t      }\n\t      ```\n\t\n\t      Asynchronous example:\n\t\n\t      ```js\n\t      findAuthor().catch(function(reason){\n\t        return findOtherAuther();\n\t      }).finally(function(){\n\t        // author was either found, or not\n\t      });\n\t      ```\n\t\n\t      @method finally\n\t      @param {Function} callback\n\t      @param {String} label optional string for labeling the promise.\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      \'finally\': function(callback, label) {\n\t        var promise = this;\n\t        var constructor = promise.constructor;\n\t\n\t        return promise.then(function(value) {\n\t          return constructor.resolve(callback()).then(function(){\n\t            return value;\n\t          });\n\t        }, function(reason) {\n\t          return constructor.resolve(callback()).then(function(){\n\t            throw reason;\n\t          });\n\t        }, label);\n\t      }\n\t    };\n\t\n\t    function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {\n\t      this._superConstructor(Constructor, entries, false /* don\'t abort on reject */, label);\n\t    }\n\t\n\t    lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);\n\t    lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;\n\t    lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;\n\t    lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {\n\t      return new Error(\'allSettled must be called with an array\');\n\t    };\n\t\n\t    function lib$rsvp$all$settled$$allSettled(entries, label) {\n\t      return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;\n\t    }\n\t    var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;\n\t    function lib$rsvp$all$$all(array, label) {\n\t      return lib$rsvp$promise$$default.all(array, label);\n\t    }\n\t    var lib$rsvp$all$$default = lib$rsvp$all$$all;\n\t    var lib$rsvp$asap$$len = 0;\n\t    var lib$rsvp$asap$$toString = {}.toString;\n\t    var lib$rsvp$asap$$vertxNext;\n\t    function lib$rsvp$asap$$asap(callback, arg) {\n\t      lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;\n\t      lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;\n\t      lib$rsvp$asap$$len += 2;\n\t      if (lib$rsvp$asap$$len === 2) {\n\t        // If len is 1, that means that we need to schedule an async flush.\n\t        // If additional callbacks are queued before the queue is flushed, they\n\t        // will be processed by this flush that we are scheduling.\n\t        lib$rsvp$asap$$scheduleFlush();\n\t      }\n\t    }\n\t\n\t    var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;\n\t\n\t    var lib$rsvp$asap$$browserWindow = (typeof window !== \'undefined\') ? window : undefined;\n\t    var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};\n\t    var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;\n\t    var lib$rsvp$asap$$isNode = typeof process !== \'undefined\' && {}.toString.call(process) === \'[object process]\';\n\t\n\t    // test for web worker but not in IE10\n\t    var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== \'undefined\' &&\n\t      typeof importScripts !== \'undefined\' &&\n\t      typeof MessageChannel !== \'undefined\';\n\t\n\t    // node\n\t    function lib$rsvp$asap$$useNextTick() {\n\t      var nextTick = process.nextTick;\n\t      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n\t      // setImmediate should be used instead instead\n\t      var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n\t      if (Array.isArray(version) && version[1] === \'0\' && version[2] === \'10\') {\n\t        nextTick = setImmediate;\n\t      }\n\t      return function() {\n\t        nextTick(lib$rsvp$asap$$flush);\n\t      };\n\t    }\n\t\n\t    // vertx\n\t    function lib$rsvp$asap$$useVertxTimer() {\n\t      return function() {\n\t        lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);\n\t      };\n\t    }\n\t\n\t    function lib$rsvp$asap$$useMutationObserver() {\n\t      var iterations = 0;\n\t      var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);\n\t      var node = document.createTextNode(\'\');\n\t      observer.observe(node, { characterData: true });\n\t\n\t      return function() {\n\t        node.data = (iterations = ++iterations % 2);\n\t      };\n\t    }\n\t\n\t    // web worker\n\t    function lib$rsvp$asap$$useMessageChannel() {\n\t      var channel = new MessageChannel();\n\t      channel.port1.onmessage = lib$rsvp$asap$$flush;\n\t      return function () {\n\t        channel.port2.postMessage(0);\n\t      };\n\t    }\n\t\n\t    function lib$rsvp$asap$$useSetTimeout() {\n\t      return function() {\n\t        setTimeout(lib$rsvp$asap$$flush, 1);\n\t      };\n\t    }\n\t\n\t    var lib$rsvp$asap$$queue = new Array(1000);\n\t    function lib$rsvp$asap$$flush() {\n\t      for (var i = 0; i < lib$rsvp$asap$$len; i+=2) {\n\t        var callback = lib$rsvp$asap$$queue[i];\n\t        var arg = lib$rsvp$asap$$queue[i+1];\n\t\n\t        callback(arg);\n\t\n\t        lib$rsvp$asap$$queue[i] = undefined;\n\t        lib$rsvp$asap$$queue[i+1] = undefined;\n\t      }\n\t\n\t      lib$rsvp$asap$$len = 0;\n\t    }\n\t\n\t    function lib$rsvp$asap$$attemptVertex() {\n\t      try {\n\t        var r = require;\n\t        var vertx = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \\"vertx\\""); e.code = \'MODULE_NOT_FOUND\'; throw e; }()));\n\t        lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n\t        return lib$rsvp$asap$$useVertxTimer();\n\t      } catch(e) {\n\t        return lib$rsvp$asap$$useSetTimeout();\n\t      }\n\t    }\n\t\n\t    var lib$rsvp$asap$$scheduleFlush;\n\t    // Decide what async method to use to triggering processing of queued callbacks:\n\t    if (lib$rsvp$asap$$isNode) {\n\t      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();\n\t    } else if (lib$rsvp$asap$$BrowserMutationObserver) {\n\t      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();\n\t    } else if (lib$rsvp$asap$$isWorker) {\n\t      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();\n\t    } else if (lib$rsvp$asap$$browserWindow === undefined && "function" === \'function\') {\n\t      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();\n\t    } else {\n\t      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();\n\t    }\n\t    function lib$rsvp$defer$$defer(label) {\n\t      var deferred = {};\n\t\n\t      deferred[\'promise\'] = new lib$rsvp$promise$$default(function(resolve, reject) {\n\t        deferred[\'resolve\'] = resolve;\n\t        deferred[\'reject\'] = reject;\n\t      }, label);\n\t\n\t      return deferred;\n\t    }\n\t    var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;\n\t    function lib$rsvp$filter$$filter(promises, filterFn, label) {\n\t      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {\n\t        if (!lib$rsvp$utils$$isFunction(filterFn)) {\n\t          throw new TypeError("You must pass a function as filter\'s second argument.");\n\t        }\n\t\n\t        var length = values.length;\n\t        var filtered = new Array(length);\n\t\n\t        for (var i = 0; i < length; i++) {\n\t          filtered[i] = filterFn(values[i]);\n\t        }\n\t\n\t        return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {\n\t          var results = new Array(length);\n\t          var newLength = 0;\n\t\n\t          for (var i = 0; i < length; i++) {\n\t            if (filtered[i]) {\n\t              results[newLength] = values[i];\n\t              newLength++;\n\t            }\n\t          }\n\t\n\t          results.length = newLength;\n\t\n\t          return results;\n\t        });\n\t      });\n\t    }\n\t    var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;\n\t\n\t    function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {\n\t      this._superConstructor(Constructor, object, true, label);\n\t    }\n\t\n\t    var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;\n\t\n\t    lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);\n\t    lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;\n\t    lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {\n\t      this._result = {};\n\t    };\n\t\n\t    lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {\n\t      return input && typeof input === \'object\';\n\t    };\n\t\n\t    lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {\n\t      return new Error(\'Promise.hash must be called with an object\');\n\t    };\n\t\n\t    lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {\n\t      var enumerator = this;\n\t      var promise    = enumerator.promise;\n\t      var input      = enumerator._input;\n\t      var results    = [];\n\t\n\t      for (var key in input) {\n\t        if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {\n\t          results.push({\n\t            position: key,\n\t            entry: input[key]\n\t          });\n\t        }\n\t      }\n\t\n\t      var length = results.length;\n\t      enumerator._remaining = length;\n\t      var result;\n\t\n\t      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n\t        result = results[i];\n\t        enumerator._eachEntry(result.entry, result.position);\n\t      }\n\t    };\n\t\n\t    function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {\n\t      this._superConstructor(Constructor, object, false, label);\n\t    }\n\t\n\t    lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);\n\t    lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;\n\t    lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;\n\t\n\t    lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {\n\t      return new Error(\'hashSettled must be called with an object\');\n\t    };\n\t\n\t    function lib$rsvp$hash$settled$$hashSettled(object, label) {\n\t      return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;\n\t    }\n\t    var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;\n\t    function lib$rsvp$hash$$hash(object, label) {\n\t      return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;\n\t    }\n\t    var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;\n\t    function lib$rsvp$map$$map(promises, mapFn, label) {\n\t      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {\n\t        if (!lib$rsvp$utils$$isFunction(mapFn)) {\n\t          throw new TypeError("You must pass a function as map\'s second argument.");\n\t        }\n\t\n\t        var length = values.length;\n\t        var results = new Array(length);\n\t\n\t        for (var i = 0; i < length; i++) {\n\t          results[i] = mapFn(values[i]);\n\t        }\n\t\n\t        return lib$rsvp$promise$$default.all(results, label);\n\t      });\n\t    }\n\t    var lib$rsvp$map$$default = lib$rsvp$map$$map;\n\t\n\t    function lib$rsvp$node$$Result() {\n\t      this.value = undefined;\n\t    }\n\t\n\t    var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();\n\t    var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();\n\t\n\t    function lib$rsvp$node$$getThen(obj) {\n\t      try {\n\t       return obj.then;\n\t      } catch(error) {\n\t        lib$rsvp$node$$ERROR.value= error;\n\t        return lib$rsvp$node$$ERROR;\n\t      }\n\t    }\n\t\n\t\n\t    function lib$rsvp$node$$tryApply(f, s, a) {\n\t      try {\n\t        f.apply(s, a);\n\t      } catch(error) {\n\t        lib$rsvp$node$$ERROR.value = error;\n\t        return lib$rsvp$node$$ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$rsvp$node$$makeObject(_, argumentNames) {\n\t      var obj = {};\n\t      var name;\n\t      var i;\n\t      var length = _.length;\n\t      var args = new Array(length);\n\t\n\t      for (var x = 0; x < length; x++) {\n\t        args[x] = _[x];\n\t      }\n\t\n\t      for (i = 0; i < argumentNames.length; i++) {\n\t        name = argumentNames[i];\n\t        obj[name] = args[i + 1];\n\t      }\n\t\n\t      return obj;\n\t    }\n\t\n\t    function lib$rsvp$node$$arrayResult(_) {\n\t      var length = _.length;\n\t      var args = new Array(length - 1);\n\t\n\t      for (var i = 1; i < length; i++) {\n\t        args[i - 1] = _[i];\n\t      }\n\t\n\t      return args;\n\t    }\n\t\n\t    function lib$rsvp$node$$wrapThenable(then, promise) {\n\t      return {\n\t        then: function(onFulFillment, onRejection) {\n\t          return then.call(promise, onFulFillment, onRejection);\n\t        }\n\t      };\n\t    }\n\t\n\t    function lib$rsvp$node$$denodeify(nodeFunc, options) {\n\t      var fn = function() {\n\t        var self = this;\n\t        var l = arguments.length;\n\t        var args = new Array(l + 1);\n\t        var arg;\n\t        var promiseInput = false;\n\t\n\t        for (var i = 0; i < l; ++i) {\n\t          arg = arguments[i];\n\t\n\t          if (!promiseInput) {\n\t            // TODO: clean this up\n\t            promiseInput = lib$rsvp$node$$needsPromiseInput(arg);\n\t            if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {\n\t              var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);\n\t              lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);\n\t              return p;\n\t            } else if (promiseInput && promiseInput !== true) {\n\t              arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);\n\t            }\n\t          }\n\t          args[i] = arg;\n\t        }\n\t\n\t        var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);\n\t\n\t        args[l] = function(err, val) {\n\t          if (err)\n\t            lib$rsvp$$internal$$reject(promise, err);\n\t          else if (options === undefined)\n\t            lib$rsvp$$internal$$resolve(promise, val);\n\t          else if (options === true)\n\t            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));\n\t          else if (lib$rsvp$utils$$isArray(options))\n\t            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));\n\t          else\n\t            lib$rsvp$$internal$$resolve(promise, val);\n\t        };\n\t\n\t        if (promiseInput) {\n\t          return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);\n\t        } else {\n\t          return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);\n\t        }\n\t      };\n\t\n\t      fn.__proto__ = nodeFunc;\n\t\n\t      return fn;\n\t    }\n\t\n\t    var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;\n\t\n\t    function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {\n\t      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);\n\t      if (result === lib$rsvp$node$$ERROR) {\n\t        lib$rsvp$$internal$$reject(promise, result.value);\n\t      }\n\t      return promise;\n\t    }\n\t\n\t    function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){\n\t      return lib$rsvp$promise$$default.all(args).then(function(args){\n\t        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);\n\t        if (result === lib$rsvp$node$$ERROR) {\n\t          lib$rsvp$$internal$$reject(promise, result.value);\n\t        }\n\t        return promise;\n\t      });\n\t    }\n\t\n\t    function lib$rsvp$node$$needsPromiseInput(arg) {\n\t      if (arg && typeof arg === \'object\') {\n\t        if (arg.constructor === lib$rsvp$promise$$default) {\n\t          return true;\n\t        } else {\n\t          return lib$rsvp$node$$getThen(arg);\n\t        }\n\t      } else {\n\t        return false;\n\t      }\n\t    }\n\t    var lib$rsvp$platform$$platform;\n\t\n\t    /* global self */\n\t    if (typeof self === \'object\') {\n\t      lib$rsvp$platform$$platform = self;\n\t\n\t    /* global global */\n\t    } else if (typeof global === \'object\') {\n\t      lib$rsvp$platform$$platform = global;\n\t    } else {\n\t      throw new Error(\'no global: `self` or `global` found\');\n\t    }\n\t\n\t    var lib$rsvp$platform$$default = lib$rsvp$platform$$platform;\n\t    function lib$rsvp$race$$race(array, label) {\n\t      return lib$rsvp$promise$$default.race(array, label);\n\t    }\n\t    var lib$rsvp$race$$default = lib$rsvp$race$$race;\n\t    function lib$rsvp$reject$$reject(reason, label) {\n\t      return lib$rsvp$promise$$default.reject(reason, label);\n\t    }\n\t    var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;\n\t    function lib$rsvp$resolve$$resolve(value, label) {\n\t      return lib$rsvp$promise$$default.resolve(value, label);\n\t    }\n\t    var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;\n\t    function lib$rsvp$rethrow$$rethrow(reason) {\n\t      setTimeout(function() {\n\t        throw reason;\n\t      });\n\t      throw reason;\n\t    }\n\t    var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;\n\t\n\t    // default async is asap;\n\t    lib$rsvp$config$$config.async = lib$rsvp$asap$$default;\n\t    var lib$rsvp$$cast = lib$rsvp$resolve$$default;\n\t    function lib$rsvp$$async(callback, arg) {\n\t      lib$rsvp$config$$config.async(callback, arg);\n\t    }\n\t\n\t    function lib$rsvp$$on() {\n\t      lib$rsvp$config$$config[\'on\'].apply(lib$rsvp$config$$config, arguments);\n\t    }\n\t\n\t    function lib$rsvp$$off() {\n\t      lib$rsvp$config$$config[\'off\'].apply(lib$rsvp$config$$config, arguments);\n\t    }\n\t\n\t    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`\n\t    if (typeof window !== \'undefined\' && typeof window[\'__PROMISE_INSTRUMENTATION__\'] === \'object\') {\n\t      var lib$rsvp$$callbacks = window[\'__PROMISE_INSTRUMENTATION__\'];\n\t      lib$rsvp$config$$configure(\'instrument\', true);\n\t      for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {\n\t        if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {\n\t          lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);\n\t        }\n\t      }\n\t    }\n\t\n\t    var lib$rsvp$umd$$RSVP = {\n\t      \'race\': lib$rsvp$race$$default,\n\t      \'Promise\': lib$rsvp$promise$$default,\n\t      \'allSettled\': lib$rsvp$all$settled$$default,\n\t      \'hash\': lib$rsvp$hash$$default,\n\t      \'hashSettled\': lib$rsvp$hash$settled$$default,\n\t      \'denodeify\': lib$rsvp$node$$default,\n\t      \'on\': lib$rsvp$$on,\n\t      \'off\': lib$rsvp$$off,\n\t      \'map\': lib$rsvp$map$$default,\n\t      \'filter\': lib$rsvp$filter$$default,\n\t      \'resolve\': lib$rsvp$resolve$$default,\n\t      \'reject\': lib$rsvp$reject$$default,\n\t      \'all\': lib$rsvp$all$$default,\n\t      \'rethrow\': lib$rsvp$rethrow$$default,\n\t      \'defer\': lib$rsvp$defer$$default,\n\t      \'EventTarget\': lib$rsvp$events$$default,\n\t      \'configure\': lib$rsvp$config$$configure,\n\t      \'async\': lib$rsvp$$async\n\t    };\n\t\n\t    /* global define:true module:true window: true */\n\t    if ("function" === \'function\' && __webpack_require__(10)[\'amd\']) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$rsvp$umd$$RSVP; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module !== \'undefined\' && module[\'exports\']) {\n\t      module[\'exports\'] = lib$rsvp$umd$$RSVP;\n\t    } else if (typeof lib$rsvp$platform$$default !== \'undefined\') {\n\t      lib$rsvp$platform$$default[\'RSVP\'] = lib$rsvp$umd$$RSVP;\n\t    }\n\t}).call(this);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(7).setImmediate, (function() { return this; }()), __webpack_require__(9)(module)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don\'t break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn\'t define any globals.  It\'s inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error(\'setTimeout has not been defined\');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error(\'clearTimeout has not been defined\');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === \'function\') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === \'function\') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn\'t available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn\'t trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it\'s a version of I.E. that must have the global object for \'this\', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn\'t available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn\'t  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it\'s a version of I.E. that must have the global object for \'this\', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = \'browser\';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = \'\'; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error(\'process.binding is not supported\');\n\t};\n\t\n\tprocess.cwd = function () { return \'/\' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error(\'process.chdir is not supported\');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n\t            (typeof self !== "undefined" && self) ||\n\t            window;\n\tvar apply = Function.prototype.apply;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) {\n\t  if (timeout) {\n\t    timeout.close();\n\t  }\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(scope, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// setimmediate attaches itself to the global object\n\t__webpack_require__(8);\n\t// On some exotic environments, it\'s not clear which object `setimmediate` was\n\t// able to install onto.  Search each possibility in the same order as the\n\t// `setimmediate` library.\n\texports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n\t                       (typeof global !== "undefined" && global.setImmediate) ||\n\t                       (this && this.setImmediate);\n\texports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n\t                         (typeof global !== "undefined" && global.clearImmediate) ||\n\t                         (this && this.clearImmediate);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n\t    "use strict";\n\t\n\t    if (global.setImmediate) {\n\t        return;\n\t    }\n\t\n\t    var nextHandle = 1; // Spec says greater than zero\n\t    var tasksByHandle = {};\n\t    var currentlyRunningATask = false;\n\t    var doc = global.document;\n\t    var registerImmediate;\n\t\n\t    function setImmediate(callback) {\n\t      // Callback can either be a function or a string\n\t      if (typeof callback !== "function") {\n\t        callback = new Function("" + callback);\n\t      }\n\t      // Copy function arguments\n\t      var args = new Array(arguments.length - 1);\n\t      for (var i = 0; i < args.length; i++) {\n\t          args[i] = arguments[i + 1];\n\t      }\n\t      // Store and register the task\n\t      var task = { callback: callback, args: args };\n\t      tasksByHandle[nextHandle] = task;\n\t      registerImmediate(nextHandle);\n\t      return nextHandle++;\n\t    }\n\t\n\t    function clearImmediate(handle) {\n\t        delete tasksByHandle[handle];\n\t    }\n\t\n\t    function run(task) {\n\t        var callback = task.callback;\n\t        var args = task.args;\n\t        switch (args.length) {\n\t        case 0:\n\t            callback();\n\t            break;\n\t        case 1:\n\t            callback(args[0]);\n\t            break;\n\t        case 2:\n\t            callback(args[0], args[1]);\n\t            break;\n\t        case 3:\n\t            callback(args[0], args[1], args[2]);\n\t            break;\n\t        default:\n\t            callback.apply(undefined, args);\n\t            break;\n\t        }\n\t    }\n\t\n\t    function runIfPresent(handle) {\n\t        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n\t        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n\t        if (currentlyRunningATask) {\n\t            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t            // "too much recursion" error.\n\t            setTimeout(runIfPresent, 0, handle);\n\t        } else {\n\t            var task = tasksByHandle[handle];\n\t            if (task) {\n\t                currentlyRunningATask = true;\n\t                try {\n\t                    run(task);\n\t                } finally {\n\t                    clearImmediate(handle);\n\t                    currentlyRunningATask = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function installNextTickImplementation() {\n\t        registerImmediate = function(handle) {\n\t            process.nextTick(function () { runIfPresent(handle); });\n\t        };\n\t    }\n\t\n\t    function canUsePostMessage() {\n\t        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n\t        if (global.postMessage && !global.importScripts) {\n\t            var postMessageIsAsynchronous = true;\n\t            var oldOnMessage = global.onmessage;\n\t            global.onmessage = function() {\n\t                postMessageIsAsynchronous = false;\n\t            };\n\t            global.postMessage("", "*");\n\t            global.onmessage = oldOnMessage;\n\t            return postMessageIsAsynchronous;\n\t        }\n\t    }\n\t\n\t    function installPostMessageImplementation() {\n\t        // Installs an event handler on `global` for the `message` event: see\n\t        // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\t\n\t        var messagePrefix = "setImmediate$" + Math.random() + "$";\n\t        var onGlobalMessage = function(event) {\n\t            if (event.source === global &&\n\t                typeof event.data === "string" &&\n\t                event.data.indexOf(messagePrefix) === 0) {\n\t                runIfPresent(+event.data.slice(messagePrefix.length));\n\t            }\n\t        };\n\t\n\t        if (global.addEventListener) {\n\t            global.addEventListener("message", onGlobalMessage, false);\n\t        } else {\n\t            global.attachEvent("onmessage", onGlobalMessage);\n\t        }\n\t\n\t        registerImmediate = function(handle) {\n\t            global.postMessage(messagePrefix + handle, "*");\n\t        };\n\t    }\n\t\n\t    function installMessageChannelImplementation() {\n\t        var channel = new MessageChannel();\n\t        channel.port1.onmessage = function(event) {\n\t            var handle = event.data;\n\t            runIfPresent(handle);\n\t        };\n\t\n\t        registerImmediate = function(handle) {\n\t            channel.port2.postMessage(handle);\n\t        };\n\t    }\n\t\n\t    function installReadyStateChangeImplementation() {\n\t        var html = doc.documentElement;\n\t        registerImmediate = function(handle) {\n\t            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n\t            var script = doc.createElement("script");\n\t            script.onreadystatechange = function () {\n\t                runIfPresent(handle);\n\t                script.onreadystatechange = null;\n\t                html.removeChild(script);\n\t                script = null;\n\t            };\n\t            html.appendChild(script);\n\t        };\n\t    }\n\t\n\t    function installSetTimeoutImplementation() {\n\t        registerImmediate = function(handle) {\n\t            setTimeout(runIfPresent, 0, handle);\n\t        };\n\t    }\n\t\n\t    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\t    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n\t    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\t\n\t    // Don\'t get fooled by e.g. browserify environments.\n\t    if ({}.toString.call(global.process) === "[object process]") {\n\t        // For Node.js before 0.9\n\t        installNextTickImplementation();\n\t\n\t    } else if (canUsePostMessage()) {\n\t        // For non-IE10 modern browsers\n\t        installPostMessageImplementation();\n\t\n\t    } else if (global.MessageChannel) {\n\t        // For web workers, where supported\n\t        installMessageChannelImplementation();\n\t\n\t    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n\t        // For IE 6\u20138\n\t        installReadyStateChangeImplementation();\n\t\n\t    } else {\n\t        // For older browsers\n\t        installSetTimeoutImplementation();\n\t    }\n\t\n\t    attachTo.setImmediate = setImmediate;\n\t    attachTo.clearImmediate = clearImmediate;\n\t}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(6)))\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error("define cannot be used indirect"); };\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t  \'use strict\';\n\t\n\t  var RSVP = __webpack_require__(5);\n\t\n\t  function BootstrapUtils() {}\n\t\n\t  //\n\t  // Returns elements for a given tagName, Arrayified\n\t  //\n\t  BootstrapUtils.getElementsByTagName = function(doc, tagName) {\n\t    var elementList = doc.getElementsByTagName(tagName);\n\t    return Array.prototype.slice.call(elementList);\n\t  };\n\t\n\t  var SRC_RE = /\\/\\w+\\/spxw\\.js/;\n\t  var BOOKMARKLET_SRC_RE = /\\/\\w+\\/spxw\\.js.bookmarklet=/;\n\t  BootstrapUtils.isSwoopScript = function(scriptEle, isBookmarklet) {\n\t    // Check for CloudFlare\n\t    var src = scriptEle.getAttribute(\'data-rocketsrc\') || scriptEle.src;\n\t\n\t    return scriptEle.hasAttribute(\'data-domain\') && ((isBookmarklet ? BOOKMARKLET_SRC_RE : SRC_RE).test(src));\n\t  };\n\t\n\t  //\n\t  // Finds all script elements that look like spxw scripts\n\t  //\n\t  BootstrapUtils.findSpxwScripts = function(doc, isBookmarklet) {\n\t    return BootstrapUtils.getElementsByTagName(doc, \'script\').filter(function(script) {\n\t      return BootstrapUtils.isSwoopScript(script, isBookmarklet);\n\t    });\n\t  };\n\t\n\t  BootstrapUtils.loadJavascript = function(doc, url) {\n\t    return new RSVP.Promise(function(resolve, reject) {\n\t      var script = doc.createElement(\'script\');\n\t      script.type = \'text/javascript\';\n\t      script.charset = \'UTF-8\';\n\t      script.src = url;\n\t      script.addEventListener(\'load\', resolve, false);\n\t      script.addEventListener(\'error\', reject, false);\n\t      doc.body.appendChild(script);\n\t    });\n\t  };\n\t\n\t  BootstrapUtils.bootError = function(url, domainId, errorDetail) {\n\t    var now = new Date();\n\t    var event = {\n\t      ts: now.getTime(),\n\t      tso: -(now.getTimezoneOffset()),\n\t      t: \'e/boot\',\n\t      v: 14,\n\t      ctx: {\n\t        cti: 0, // web-sdk client type id\n\t        url: url,\n\t        did: domainId\n\t      },\n\t      d: {\n\t        errorArgs: errorDetail\n\t      }\n\t    };\n\t\n\t    var request = new XMLHttpRequest();\n\t    request.open(\'POST\', (\'https://www.swpsvc.com\') + \'/s/log\', true);\n\t    request.setRequestHeader(\'Content-Type\', \'application/json; charset=UTF-8\');\n\t    request.send(JSON.stringify(event));\n\t  };\n\t\n\t  BootstrapUtils.buildLinkElement = function(doc, rel, href, crossorigin) {\n\t    var ele = doc.createElement(\'link\');\n\t    ele.setAttribute(\'rel\', rel);\n\t    ele.setAttribute(\'href\', href);\n\t\n\t    if (crossorigin) ele.setAttribute(\'crossorigin\', \'\');\n\t\n\t    return ele;\n\t  };\n\t\n\t  BootstrapUtils.composeUrl = function(base, params) {\n\t    var query = \'\';\n\t    for (var key in params) {\n\t      if (params[key]) {\n\t        query += (query ? \'&\' : \'?\') + key + \'=\' + encodeURIComponent(params[key]);\n\t      }\n\t    }\n\t    query += \'&\' + new Date().valueOf(); // cache buster\n\t    return base + query;\n\t  };\n\t\n\t  //\n\t  // Find all query params on the URL that match the given regex/\n\t  // Returns a map of the params and the url with the params removed\n\t  //\n\t  var SPX_PARAMS_REGEX = /[?&]spx_([^=]+)=([^&#]+)/gi; // params of the form `spx_<name>=<value>`\n\t  BootstrapUtils.extractSPXParams = function(url) {\n\t    var matchGroup = SPX_PARAMS_REGEX.exec(url), matches = [];\n\t    while (matchGroup) {\n\t      matches.push(matchGroup);\n\t      matchGroup = SPX_PARAMS_REGEX.exec(url);\n\t    }\n\t\n\t    var params = {};\n\t    matches.forEach(function(match) {\n\t      var fullMatch = match[0];\n\t      var param = match[1];\n\t      var value = match[2];\n\t\n\t      // Support duplicate params by placing them in an array\n\t      if (params[param] !== undefined) {\n\t        if (!(params[param] instanceof Array)) {\n\t          params[param] = [params[param]];\n\t        }\n\t\n\t        params[param].push(value);\n\t      } else {\n\t        params[param] = value;\n\t      }\n\t\n\t      if (fullMatch[0] === \'?\') {\n\t        fullMatch = fullMatch.substr(1);\n\t      }\n\t      url = url.replace(fullMatch, \'\');\n\t    });\n\t\n\t    // Only perform cleanup if we removed anything from the URL\n\t    if (Object.keys(params).length > 0) {\n\t      // Remove dangling `?` on the final url\n\t      //TODO this does not cover url fragments but the normalizer appears to handle this\n\t      if (url[url.length - 1] === \'?\') {\n\t        url = url.substr(0, url.length - 1);\n\t      }\n\t    }\n\t\n\t    return {\n\t      url: url,\n\t      params: params\n\t    };\n\t  };\n\t\n\t  //RFC4122 compliant. Best we can do in client side javascript\n\t  BootstrapUtils.getGUID = function() {\n\t    return \'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\'.replace(/[xy]/g, function(c) {\n\t      var r = Math.random() * 16 | 0, v = c === \'x\' ? r : (r & 0x3 | 0x8);\n\t      return v.toString(16);\n\t    });\n\t  };\n\t\n\t  // Based on http://www.paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/\n\t  // Example: spxLog(\'Data is\', data)\n\t  BootstrapUtils.log = function() {\n\t    BootstrapUtils.trace(arguments);\n\t    if (console && console.log) {\n\t      try {\n\t        console.log(arguments);\n\t      } catch(e) {}\n\t    }\n\t  };\n\t\n\t  // Logs information and throws an error\n\t  BootstrapUtils.throw = function(msg) {\n\t    msg = \'SPX \' + msg;\n\t    BootstrapUtils.log(msg, arguments);\n\t    throw msg;\n\t  };\n\t\n\t  // Collects a log history in SPX.trace.history. Useful for debugging.\n\t  // Example: SPX.trace(\'Bad problem\', badData)\n\t  // Dumping the trace in the console: SPX.trace.dump()\n\t  BootstrapUtils.trace = function spxTrace() {\n\t    BootstrapUtils.trace.history = BootstrapUtils.trace.history || [];   // store logs to an array for reference\n\t    // @todo consider adding timestamps, current window reference, etc.\n\t    BootstrapUtils.trace.history.push(arguments);\n\t  };\n\t\n\t  BootstrapUtils.trace.dump = function() {\n\t    return JSON.stringify(BootstrapUtils.trace.history, null, 2);\n\t  };\n\t\n\t  BootstrapUtils.xhrGet = function (url, contentType) {\n\t    contentType = contentType || \'application/json\';\n\t\n\t    return new RSVP.Promise(function (resolve, reject) {\n\t      var xhr = new XMLHttpRequest();\n\t      xhr.onreadystatechange = function () {\n\t        if (this.readyState !== XMLHttpRequest.DONE) return;\n\t        this.status === 200 ? resolve(this) : reject(this);\n\t      };\n\t      xhr.open(\'GET\', url, true);\n\t      xhr.setRequestHeader(\'Accept\', contentType);\n\t      xhr.withCredentials = true;\n\t      xhr.send();\n\t    });\n\t  };\n\t\n\t  return BootstrapUtils;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {\n\t\t\'use strict\';\n\t\n\t\tvar RSVP = __webpack_require__(5);\n\t\tvar utils = __webpack_require__(11);\n\t\tvar _ = __webpack_require__(13);\n\t\tvar g = __webpack_require__(14)\n\t\n\t\tvar TREND_NPI_ORIGINS = [\n\t\t\t\'SW-59153175-2IAB\', // MNT Mobile\n\t\t\t\'SW-65624350-44825\' // Healthline\n\t\t]\n\t\n\t\tfunction Identity () {\n\t\t\tthis.data = {}\n\t\t}\n\t\n\t\tIdentity.prototype.getIds = function () {\n\t\t\treturn _.mapValues(this.data, \'id\');\n\t\t}\n\t\n\t\tIdentity.prototype.getResolveTiming = function () {\n\t\t\treturn _.mapValues(this.data, \'resolveTime\');\n\t\t}\n\t\n\t\tIdentity.prototype.loadIds = function (originId) {\n\t\t\tvar me = this;\n\t\n\t\t\tvar plsPromise = this._publisherLocalStorage().then(function(result) {\n\t\t\t\tme.data[\'pls\'] = result;\n\t\t\t});\n\t\n\t\t\tvar idlPromise = this._liveRampIdl().then(function(result) {\n\t\t\t\tme.data[\'idl\'] = result;\n\t\t\t});\n\t\n\t\t\tvar npiPromise = this._scriptNPI().then(function(result) {\n\t\t\t\tme.data[\'npi\'] = result;\n\t\t\t});\n\t\n\t\t\tvar idPromises = [\n\t\t\t\tplsPromise,\n\t\t\t\tidlPromise,\n\t\t\t\tnpiPromise\n\t\t\t];\n\t\n\t\t\tif (_.includes(TREND_NPI_ORIGINS, originId)) {\n\t\t\t\tidPromises.push(this._requestTrendNpi().then(function(result) {\n\t\t\t\t\tme.data[\'npi\'] = result;\n\t\t\t\t}));\n\t\t\t}\n\t\n\t\t\tthis.allLoadedPromise = RSVP.allSettled(idPromises).then(function() { me._loadComplete = true; });\n\t\n\t\t\treturn this.allLoadedPromise;\n\t\t}\n\t\n\t\tIdentity.prototype.waitForIds = function (waitTime) {\n\t\t\tvar me = this;\n\t\n\t\t\treturn RSVP.Promise.race([this.allLoadedPromise, new RSVP.Promise(resolve => setTimeout(resolve, waitTime))])\n\t\t\t\t.then(() => {\n\t\t\t\t\treturn me.getIds();\n\t\t\t\t});\n\t\t}\n\t\n\t\tIdentity.DEFAULT_TTL = (1000 * 60 * 60 * 24 * 30);\n\t\n\t\t// Stores an ID in localstorage scoped to the publisher domain\n\t\tIdentity.PUBLISHER_LOCAL_STORAGE_TTL = Identity.DEFAULT_TTL;\n\t\tIdentity.PUBLISHER_LOCAL_STORAGE_KEY = \'__spx__pls\';\n\t\tIdentity.prototype._publisherLocalStorage = function () {\n\t\t\treturn new RSVP.Promise(function(resolve) {\n\t\t\t\tvar perfNow = window.performance.now();\n\t\t\t\tvar now = new Date().getTime();\n\t\n\t\t\t\tvar data = JSON.parse(\n\t\t\t\t\twindow.localStorage.getItem(Identity.PUBLISHER_LOCAL_STORAGE_KEY) || "{}"\n\t\t\t\t);\n\t\n\t\t\t\tvar id = data.id;\n\t\t\t\tvar expiresAt = data.expiresAt;\n\t\n\t\t\t\tif (expiresAt && expiresAt <= now) { id = null; }\n\t\t\t\tid = id || utils.getGUID();\n\t\n\t\t\t\texpiresAt = now + Identity.PUBLISHER_LOCAL_STORAGE_TTL;\n\t\n\t\t\t\twindow.localStorage.setItem(Identity.PUBLISHER_LOCAL_STORAGE_KEY, JSON.stringify({\n\t\t\t\t\tid: id,\n\t\t\t\t\texpiresAt: expiresAt\n\t\t\t\t}));\n\t\n\t\t\t\tresolve({ id: id, resolveTime: Math.round(window.performance.now() - perfNow) });\n\t\t\t});\n\t\t}\n\t\n\t\t// Makes a JSONP request to liveramp to get a identity link id\n\t\t// NOTE: Identity is loaded very early in the spxw startup long before we have supporting\n\t\t// libraries available so we\'re \'manually\' constructing the JSONP call here.\n\t\tIdentity.prototype._liveRampIdl = function () {\n\t\t\treturn new RSVP.Promise(function(resolve, reject) {\n\t\t\t\tvar perfNow =  window.performance.now();\n\t\n\t\t\t\tutils.xhrGet((\'https://api.rlcdn.com/api/identity/idl?pid=7\')).then(function(resp) {\n\t\t\t\t\tvar data = JSON.parse(resp.responseText);\n\t\t\t\t\tresolve({ id: data.idl, resolveTime: Math.round(window.performance.now() - perfNow) });\n\t\t\t\t}).catch(reject);\n\t\t\t});\n\t\t}\n\t\n\t\tIdentity.prototype._scriptNPI = function () {\n\t\t\treturn new RSVP.Promise(function(resolve, reject) {\n\t\t\t\tvar scripts = utils.findSpxwScripts(window.parent.document);\n\t\t\t\tvar script = scripts[scripts.length - 1]; // Taking the last tag matches with bookmarklet functionality\n\t\n\t\t\t\tvar val = script.getAttribute(\'data-npi\');\n\t\t\t\tif (val != null) {\n\t\t\t\t\tresolve({ id: val, resolveTime: 0 });\n\t\t\t\t} else {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tIdentity.prototype._requestTrendNpi = function () {\n\t\t\tlet perfNow = window.performance.now();\n\t\n\t\t\tvar _resolve;\n\t\n\t\t\tg._npi_cb = function (npi) {\n\t\t\t\tif (npi === \'-1\' || npi === -1) return; // Still thinking\n\t\n\t\t\t\tif (npi === \'0\') npi = \'\'; // No NPI\n\t\n\t\t\t\t_resolve({\n\t\t\t\t\tid: npi || \'\',\n\t\t\t\t\tresolveTime: Math.round(window.performance.now() - perfNow)\n\t\t\t\t});\n\t\n\t\t\t\tdelete g._npi_cb;\n\t\t\t};\n\t\n\t\t\tvar script = g.document.createElement(\'script\');\n\t\t\tscript.setAttribute(\'src\', \'https://js.fluidity.press/swoop.min.js\');\n\t\t\tscript.setAttribute(\'data-swp\', \'true\');\n\t\n\t\t\tg.document.head.appendChild(script);\n\t\n\t\t\treturn new RSVP.Promise((resolve) => { _resolve = resolve; });\n\t\t};\n\t\n\t\tIdentity.initialize = function (originId) {\n\t\t\tif (Identity._loadingPromise) return Identity._loadingPromise;\n\t\n\t\t\tIdentity._loadingPromise = Identity.get().loadIds(originId).then(function () {\n\t\t\t\tIdentity._loadingPromise = null;\n\t\t\t\treturn Identity.get();\n\t\t\t});\n\t\n\t\t\treturn Identity._loadingPromise;\n\t\t}\n\t\n\t\tIdentity.get = function () {\n\t\t\tif (!Identity._instance) Identity._instance = new Identity();\n\t\n\t\t\treturn Identity._instance;\n\t\t}\n\t\n\t\tIdentity.clear = function () {\n\t\t\tif (Identity._loadingPromise) {\n\t\t\t\tthrow new Error(\'Cannot clear Identify while ids are loading\');\n\t\t\t}\n\t\n\t\t\tIdentity._instance = null;\n\t\t\tIdentity._loadingPromise = null;\n\t\t}\n\t\n\t\treturn Identity;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**\n\t * @license\n\t * lodash 3.10.1 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern -o libs/lodash.js -d exports="amd" include=",all,any,assign,bind,bindAll,clone,cloneDeep,compact,contains,countBy,create,defaults,defaultsDeep,difference,each,endsWith,extend,filter,find,flatten,flattenDeep,forEach,forOwn,functions,get,includes,indexOf,invert,isArray,isBoolean,isEmpty,isError,isFunction,isNaN,isNull,isNumber,isObject,isString,isUndefined,keys,map,mapKeys,mapValues,max,merge,omit,padLeft,pick,pluck,random,reduce,remove,set,size,some,sortBy,startsWith,template,throttle,times,union,uniq,uniqueId,values,"`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t;(function() {\n\t\n\t  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n\t  var undefined;\n\t\n\t  /** Used as the semantic version number. */\n\t  var VERSION = \'3.10.1\';\n\t\n\t  /** Used to compose bitmasks for wrapper metadata. */\n\t  var BIND_FLAG = 1,\n\t      BIND_KEY_FLAG = 2,\n\t      CURRY_BOUND_FLAG = 4,\n\t      CURRY_FLAG = 8,\n\t      CURRY_RIGHT_FLAG = 16,\n\t      PARTIAL_FLAG = 32,\n\t      PARTIAL_RIGHT_FLAG = 64,\n\t      ARY_FLAG = 128,\n\t      REARG_FLAG = 256;\n\t\n\t  /** Used to detect when a function becomes hot. */\n\t  var HOT_COUNT = 150,\n\t      HOT_SPAN = 16;\n\t\n\t  /** Used as the size to enable large array optimizations. */\n\t  var LARGE_ARRAY_SIZE = 200;\n\t\n\t  /** Used as the `TypeError` message for "Functions" methods. */\n\t  var FUNC_ERROR_TEXT = \'Expected a function\';\n\t\n\t  /** Used as the internal argument placeholder. */\n\t  var PLACEHOLDER = \'__lodash_placeholder__\';\n\t\n\t  /** `Object#toString` result references. */\n\t  var argsTag = \'[object Arguments]\',\n\t      arrayTag = \'[object Array]\',\n\t      boolTag = \'[object Boolean]\',\n\t      dateTag = \'[object Date]\',\n\t      errorTag = \'[object Error]\',\n\t      funcTag = \'[object Function]\',\n\t      mapTag = \'[object Map]\',\n\t      numberTag = \'[object Number]\',\n\t      objectTag = \'[object Object]\',\n\t      regexpTag = \'[object RegExp]\',\n\t      setTag = \'[object Set]\',\n\t      stringTag = \'[object String]\',\n\t      weakMapTag = \'[object WeakMap]\';\n\t\n\t  var arrayBufferTag = \'[object ArrayBuffer]\',\n\t      float32Tag = \'[object Float32Array]\',\n\t      float64Tag = \'[object Float64Array]\',\n\t      int8Tag = \'[object Int8Array]\',\n\t      int16Tag = \'[object Int16Array]\',\n\t      int32Tag = \'[object Int32Array]\',\n\t      uint8Tag = \'[object Uint8Array]\',\n\t      uint8ClampedTag = \'[object Uint8ClampedArray]\',\n\t      uint16Tag = \'[object Uint16Array]\',\n\t      uint32Tag = \'[object Uint32Array]\';\n\t\n\t  /** Used to match empty string literals in compiled template source. */\n\t  var reEmptyStringLeading = /\\b__p \\+= \'\';/g,\n\t      reEmptyStringMiddle = /\\b(__p \\+=) \'\' \\+/g,\n\t      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n\'\';/g;\n\t\n\t  /** Used to match HTML entities and HTML characters. */\n\t  var reUnescapedHtml = /[&<>"\'`]/g,\n\t      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\t\n\t  /** Used to match template delimiters. */\n\t  var reEscape = /<%-([\\s\\S]+?)%>/g,\n\t      reEvaluate = /<%([\\s\\S]+?)%>/g,\n\t      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\t\n\t  /** Used to match property names within property paths. */\n\t  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|(["\'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?\\1)\\]/,\n\t      reIsPlainProp = /^\\w*$/,\n\t      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|(["\'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g;\n\t\n\t  /** Used to match backslashes in property paths. */\n\t  var reEscapeChar = /\\\\(\\\\)?/g;\n\t\n\t  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */\n\t  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\t\n\t  /** Used to match `RegExp` flags from their coerced string values. */\n\t  var reFlags = /\\w*$/;\n\t\n\t  /** Used to detect host constructors (Safari > 5). */\n\t  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t  /** Used to detect unsigned integer values. */\n\t  var reIsUint = /^\\d+$/;\n\t\n\t  /** Used to ensure capturing order of template delimiters. */\n\t  var reNoMatch = /($^)/;\n\t\n\t  /** Used to match unescaped characters in compiled string literals. */\n\t  var reUnescapedString = /[\'\\n\\r\\u2028\\u2029\\\\]/g;\n\t\n\t  /** Used to make template sourceURLs easier to identify. */\n\t  var templateCounter = -1;\n\t\n\t  /** Used to identify `toStringTag` values of typed arrays. */\n\t  var typedArrayTags = {};\n\t  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\t  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\t  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\t  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\t  typedArrayTags[uint32Tag] = true;\n\t  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n\t  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\t  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n\t  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n\t  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n\t  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n\t  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\t\n\t  /** Used to identify `toStringTag` values supported by `_.clone`. */\n\t  var cloneableTags = {};\n\t  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n\t  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n\t  cloneableTags[dateTag] = cloneableTags[float32Tag] =\n\t  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n\t  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n\t  cloneableTags[numberTag] = cloneableTags[objectTag] =\n\t  cloneableTags[regexpTag] = cloneableTags[stringTag] =\n\t  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n\t  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n\t  cloneableTags[errorTag] = cloneableTags[funcTag] =\n\t  cloneableTags[mapTag] = cloneableTags[setTag] =\n\t  cloneableTags[weakMapTag] = false;\n\t\n\t  /** Used to map characters to HTML entities. */\n\t  var htmlEscapes = {\n\t    \'&\': \'&amp;\',\n\t    \'<\': \'&lt;\',\n\t    \'>\': \'&gt;\',\n\t    \'"\': \'&quot;\',\n\t    "\'": \'&#39;\',\n\t    \'`\': \'&#96;\'\n\t  };\n\t\n\t  /** Used to determine if values are of the language type `Object`. */\n\t  var objectTypes = {\n\t    \'function\': true,\n\t    \'object\': true\n\t  };\n\t\n\t  /** Used to escape characters for inclusion in compiled string literals. */\n\t  var stringEscapes = {\n\t    \'\\\\\': \'\\\\\',\n\t    "\'": "\'",\n\t    \'\\n\': \'n\',\n\t    \'\\r\': \'r\',\n\t    \'\\u2028\': \'u2028\',\n\t    \'\\u2029\': \'u2029\'\n\t  };\n\t\n\t  /** Detect free variable `exports`. */\n\t  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\t\n\t  /** Detect free variable `module`. */\n\t  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\t\n\t  /** Detect free variable `global` from Node.js. */\n\t  var freeGlobal = freeExports && freeModule && typeof global == \'object\' && global && global.Object && global;\n\t\n\t  /** Detect free variable `self`. */\n\t  var freeSelf = objectTypes[typeof self] && self && self.Object && self;\n\t\n\t  /** Detect free variable `window`. */\n\t  var freeWindow = objectTypes[typeof window] && window && window.Object && window;\n\t\n\t  /**\n\t   * Used as a reference to the global object.\n\t   *\n\t   * The `this` value is used if it\'s the global object to avoid Greasemonkey\'s\n\t   * restricted `window` object, otherwise the `window` object is used.\n\t   */\n\t  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * The base implementation of `compareAscending` which compares values and\n\t   * sorts them in ascending order without guaranteeing a stable sort.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to compare.\n\t   * @param {*} other The other value to compare.\n\t   * @returns {number} Returns the sort order indicator for `value`.\n\t   */\n\t  function baseCompareAscending(value, other) {\n\t    if (value !== other) {\n\t      var valIsNull = value === null,\n\t          valIsUndef = value === undefined,\n\t          valIsReflexive = value === value;\n\t\n\t      var othIsNull = other === null,\n\t          othIsUndef = other === undefined,\n\t          othIsReflexive = other === other;\n\t\n\t      if ((value > other && !othIsNull) || !valIsReflexive ||\n\t          (valIsNull && !othIsUndef && othIsReflexive) ||\n\t          (valIsUndef && othIsReflexive)) {\n\t        return 1;\n\t      }\n\t      if ((value < other && !valIsNull) || !othIsReflexive ||\n\t          (othIsNull && !valIsUndef && valIsReflexive) ||\n\t          (othIsUndef && valIsReflexive)) {\n\t        return -1;\n\t      }\n\t    }\n\t    return 0;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n\t   * support for callback shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseFindIndex(array, predicate, fromRight) {\n\t    var length = array.length,\n\t        index = fromRight ? length : -1;\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      if (predicate(array[index], index, array)) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.indexOf` without support for binary searches.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {*} value The value to search for.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseIndexOf(array, value, fromIndex) {\n\t    if (value !== value) {\n\t      return indexOfNaN(array, fromIndex);\n\t    }\n\t    var index = fromIndex - 1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (array[index] === value) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * Converts `value` to a string if it\'s not one. An empty string is returned\n\t   * for `null` or `undefined` values.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to process.\n\t   * @returns {string} Returns the string.\n\t   */\n\t  function baseToString(value) {\n\t    return value == null ? \'\' : (value + \'\');\n\t  }\n\t\n\t  /**\n\t   * Used by `_.sortBy` to compare transformed elements of a collection and stable\n\t   * sort them in ascending order.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to compare.\n\t   * @param {Object} other The other object to compare.\n\t   * @returns {number} Returns the sort order indicator for `object`.\n\t   */\n\t  function compareAscending(object, other) {\n\t    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\n\t  }\n\t\n\t  /**\n\t   * Used by `_.escape` to convert characters to HTML entities.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeHtmlChar(chr) {\n\t    return htmlEscapes[chr];\n\t  }\n\t\n\t  /**\n\t   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeStringChar(chr) {\n\t    return \'\\\\\' + stringEscapes[chr];\n\t  }\n\t\n\t  /**\n\t   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n\t   */\n\t  function indexOfNaN(array, fromIndex, fromRight) {\n\t    var length = array.length,\n\t        index = fromIndex + (fromRight ? 0 : -1);\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      var other = array[index];\n\t      if (other !== other) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is object-like.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t   */\n\t  function isObjectLike(value) {\n\t    return !!value && typeof value == \'object\';\n\t  }\n\t\n\t  /**\n\t   * Replaces all `placeholder` elements in `array` with an internal placeholder\n\t   * and returns an array of their indexes.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to modify.\n\t   * @param {*} placeholder The placeholder to replace.\n\t   * @returns {Array} Returns the new array of placeholder indexes.\n\t   */\n\t  function replaceHolders(array, placeholder) {\n\t    var index = -1,\n\t        length = array.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      if (array[index] === placeholder) {\n\t        array[index] = PLACEHOLDER;\n\t        result[++resIndex] = index;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * An implementation of `_.uniq` optimized for sorted arrays without support\n\t   * for callback shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {Function} [iteratee] The function invoked per iteration.\n\t   * @returns {Array} Returns the new duplicate free array.\n\t   */\n\t  function sortedUniq(array, iteratee) {\n\t    var seen,\n\t        index = -1,\n\t        length = array.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      var value = array[index],\n\t          computed = iteratee ? iteratee(value, index, array) : value;\n\t\n\t      if (!index || seen !== computed) {\n\t        seen = computed;\n\t        result[++resIndex] = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /** Used for native method references. */\n\t  var arrayProto = Array.prototype,\n\t      objectProto = Object.prototype;\n\t\n\t  /** Used to resolve the decompiled source of functions. */\n\t  var fnToString = Function.prototype.toString;\n\t\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t  /** Used to generate unique IDs. */\n\t  var idCounter = 0;\n\t\n\t  /**\n\t   * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n\t   * of values.\n\t   */\n\t  var objToString = objectProto.toString;\n\t\n\t  /** Used to detect if a method is native. */\n\t  var reIsNative = RegExp(\'^\' +\n\t    fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, \'\\\\$&\')\n\t    .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \'$1.*?\') + \'$\'\n\t  );\n\t\n\t  /** Native method references. */\n\t  var ArrayBuffer = root.ArrayBuffer,\n\t      propertyIsEnumerable = objectProto.propertyIsEnumerable,\n\t      Set = getNative(root, \'Set\'),\n\t      splice = arrayProto.splice,\n\t      Uint8Array = root.Uint8Array,\n\t      WeakMap = getNative(root, \'WeakMap\');\n\t\n\t  /* Native method references for those with the same name as other `lodash` methods. */\n\t  var nativeCeil = Math.ceil,\n\t      nativeCreate = getNative(Object, \'create\'),\n\t      nativeFloor = Math.floor,\n\t      nativeIsArray = getNative(Array, \'isArray\'),\n\t      nativeIsFinite = root.isFinite,\n\t      nativeKeys = getNative(Object, \'keys\'),\n\t      nativeMax = Math.max,\n\t      nativeMin = Math.min,\n\t      nativeNow = getNative(Date, \'now\'),\n\t      nativeRandom = Math.random;\n\t\n\t  /** Used as references for `-Infinity` and `Infinity`. */\n\t  var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n\t      POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\t\n\t  /** Used as references for the maximum length and index of an array. */\n\t  var MAX_ARRAY_LENGTH = 4294967295,\n\t      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n\t      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\t\n\t  /**\n\t   * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n\t   * of an array-like value.\n\t   */\n\t  var MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t  /** Used to store function metadata. */\n\t  var metaMap = WeakMap && new WeakMap;\n\t\n\t  /** Used to lookup unminified function names. */\n\t  var realNames = {};\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Creates a `lodash` object which wraps `value` to enable implicit chaining.\n\t   * Methods that operate on and return arrays, collections, and functions can\n\t   * be chained together. Methods that retrieve a single value or may return a\n\t   * primitive value will automatically end the chain returning the unwrapped\n\t   * value. Explicit chaining may be enabled using `_.chain`. The execution of\n\t   * chained methods is lazy, that is, execution is deferred until `_#value`\n\t   * is implicitly or explicitly called.\n\t   *\n\t   * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n\t   * fusion is an optimization strategy which merge iteratee calls; this can help\n\t   * to avoid the creation of intermediate data structures and greatly reduce the\n\t   * number of iteratee executions.\n\t   *\n\t   * Chaining is supported in custom builds as long as the `_#value` method is\n\t   * directly or indirectly included in the build.\n\t   *\n\t   * In addition to lodash methods, wrappers have `Array` and `String` methods.\n\t   *\n\t   * The wrapper `Array` methods are:\n\t   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,\n\t   * `splice`, and `unshift`\n\t   *\n\t   * The wrapper `String` methods are:\n\t   * `replace` and `split`\n\t   *\n\t   * The wrapper methods that support shortcut fusion are:\n\t   * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\n\t   * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\n\t   * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\n\t   * and `where`\n\t   *\n\t   * The chainable wrapper methods are:\n\t   * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\n\t   * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\n\t   * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,\n\t   * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,\n\t   * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,\n\t   * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n\t   * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n\t   * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,\n\t   * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,\n\t   * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\n\t   * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\n\t   * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,\n\t   * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,\n\t   * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,\n\t   * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,\n\t   * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,\n\t   * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`\n\t   *\n\t   * The wrapper methods that are **not** chainable by default are:\n\t   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,\n\t   * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,\n\t   * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,\n\t   * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,\n\t   * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n\t   * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,\n\t   * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,\n\t   * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,\n\t   * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,\n\t   * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,\n\t   * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,\n\t   * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,\n\t   * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,\n\t   * `unescape`, `uniqueId`, `value`, and `words`\n\t   *\n\t   * The wrapper method `sample` will return a wrapped value when `n` is provided,\n\t   * otherwise an unwrapped value is returned.\n\t   *\n\t   * @name _\n\t   * @constructor\n\t   * @category Chain\n\t   * @param {*} value The value to wrap in a `lodash` instance.\n\t   * @returns {Object} Returns the new `lodash` wrapper instance.\n\t   * @example\n\t   *\n\t   * var wrapped = _([1, 2, 3]);\n\t   *\n\t   * // returns an unwrapped value\n\t   * wrapped.reduce(function(total, n) {\n\t   *   return total + n;\n\t   * });\n\t   * // => 6\n\t   *\n\t   * // returns a wrapped value\n\t   * var squares = wrapped.map(function(n) {\n\t   *   return n * n;\n\t   * });\n\t   *\n\t   * _.isArray(squares);\n\t   * // => false\n\t   *\n\t   * _.isArray(squares.value());\n\t   * // => true\n\t   */\n\t  function lodash() {\n\t    // No operation performed.\n\t  }\n\t\n\t  /**\n\t   * The function whose prototype all chaining wrappers inherit from.\n\t   *\n\t   * @private\n\t   */\n\t  function baseLodash() {\n\t    // No operation performed.\n\t  }\n\t\n\t  /**\n\t   * By default, the template delimiters used by lodash are like those in\n\t   * embedded Ruby (ERB). Change the following template settings to use\n\t   * alternative delimiters.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @type Object\n\t   */\n\t  lodash.templateSettings = {\n\t\n\t    /**\n\t     * Used to detect `data` property values to be HTML-escaped.\n\t     *\n\t     * @memberOf _.templateSettings\n\t     * @type RegExp\n\t     */\n\t    \'escape\': reEscape,\n\t\n\t    /**\n\t     * Used to detect code to be evaluated.\n\t     *\n\t     * @memberOf _.templateSettings\n\t     * @type RegExp\n\t     */\n\t    \'evaluate\': reEvaluate,\n\t\n\t    /**\n\t     * Used to detect `data` property values to inject.\n\t     *\n\t     * @memberOf _.templateSettings\n\t     * @type RegExp\n\t     */\n\t    \'interpolate\': reInterpolate,\n\t\n\t    /**\n\t     * Used to reference the data object in the template text.\n\t     *\n\t     * @memberOf _.templateSettings\n\t     * @type string\n\t     */\n\t    \'variable\': \'\',\n\t\n\t    /**\n\t     * Used to import variables into the compiled template.\n\t     *\n\t     * @memberOf _.templateSettings\n\t     * @type Object\n\t     */\n\t    \'imports\': {\n\t\n\t      /**\n\t       * A reference to the `lodash` function.\n\t       *\n\t       * @memberOf _.templateSettings.imports\n\t       * @type Function\n\t       */\n\t      \'_\': lodash\n\t    }\n\t  };\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to wrap.\n\t   */\n\t  function LazyWrapper(value) {\n\t    this.__wrapped__ = value;\n\t    this.__actions__ = [];\n\t    this.__dir__ = 1;\n\t    this.__filtered__ = false;\n\t    this.__iteratees__ = [];\n\t    this.__takeCount__ = POSITIVE_INFINITY;\n\t    this.__views__ = [];\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   *\n\t   * Creates a cache object to store unique values.\n\t   *\n\t   * @private\n\t   * @param {Array} [values] The values to cache.\n\t   */\n\t  function SetCache(values) {\n\t    var length = values ? values.length : 0;\n\t\n\t    this.data = { \'hash\': nativeCreate(null), \'set\': new Set };\n\t    while (length--) {\n\t      this.push(values[length]);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is in `cache` mimicking the return signature of\n\t   * `_.indexOf` by returning `0` if the value is found, else `-1`.\n\t   *\n\t   * @private\n\t   * @param {Object} cache The cache to search.\n\t   * @param {*} value The value to search for.\n\t   * @returns {number} Returns `0` if `value` is found, else `-1`.\n\t   */\n\t  function cacheIndexOf(cache, value) {\n\t    var data = cache.data,\n\t        result = (typeof value == \'string\' || isObject(value)) ? data.set.has(value) : data.hash[value];\n\t\n\t    return result ? 0 : -1;\n\t  }\n\t\n\t  /**\n\t   * Adds `value` to the cache.\n\t   *\n\t   * @private\n\t   * @name push\n\t   * @memberOf SetCache\n\t   * @param {*} value The value to cache.\n\t   */\n\t  function cachePush(value) {\n\t    var data = this.data;\n\t    if (typeof value == \'string\' || isObject(value)) {\n\t      data.set.add(value);\n\t    } else {\n\t      data.hash[value] = true;\n\t    }\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Copies the values of `source` to `array`.\n\t   *\n\t   * @private\n\t   * @param {Array} source The array to copy values from.\n\t   * @param {Array} [array=[]] The array to copy values to.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function arrayCopy(source, array) {\n\t    var index = -1,\n\t        length = source.length;\n\t\n\t    array || (array = Array(length));\n\t    while (++index < length) {\n\t      array[index] = source[index];\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.forEach` for arrays without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function arrayEach(array, iteratee) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (iteratee(array[index], index, array) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.every` for arrays without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t   *  else `false`.\n\t   */\n\t  function arrayEvery(array, predicate) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (!predicate(array[index], index, array)) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `baseExtremum` for arrays which invokes `iteratee`\n\t   * with one argument: (value).\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {Function} comparator The function used to compare values.\n\t   * @param {*} exValue The initial extremum value.\n\t   * @returns {*} Returns the extremum value.\n\t   */\n\t  function arrayExtremum(array, iteratee, comparator, exValue) {\n\t    var index = -1,\n\t        length = array.length,\n\t        computed = exValue,\n\t        result = computed;\n\t\n\t    while (++index < length) {\n\t      var value = array[index],\n\t          current = +iteratee(value);\n\t\n\t      if (comparator(current, computed)) {\n\t        computed = current;\n\t        result = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.filter` for arrays without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {Array} Returns the new filtered array.\n\t   */\n\t  function arrayFilter(array, predicate) {\n\t    var index = -1,\n\t        length = array.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      var value = array[index];\n\t      if (predicate(value, index, array)) {\n\t        result[++resIndex] = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.map` for arrays without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns the new mapped array.\n\t   */\n\t  function arrayMap(array, iteratee) {\n\t    var index = -1,\n\t        length = array.length,\n\t        result = Array(length);\n\t\n\t    while (++index < length) {\n\t      result[index] = iteratee(array[index], index, array);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Appends the elements of `values` to `array`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to modify.\n\t   * @param {Array} values The values to append.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function arrayPush(array, values) {\n\t    var index = -1,\n\t        length = values.length,\n\t        offset = array.length;\n\t\n\t    while (++index < length) {\n\t      array[offset + index] = values[index];\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.reduce` for arrays without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {*} [accumulator] The initial value.\n\t   * @param {boolean} [initFromArray] Specify using the first element of `array`\n\t   *  as the initial value.\n\t   * @returns {*} Returns the accumulated value.\n\t   */\n\t  function arrayReduce(array, iteratee, accumulator, initFromArray) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    if (initFromArray && length) {\n\t      accumulator = array[++index];\n\t    }\n\t    while (++index < length) {\n\t      accumulator = iteratee(accumulator, array[index], index, array);\n\t    }\n\t    return accumulator;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.some` for arrays without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t   *  else `false`.\n\t   */\n\t  function arraySome(array, predicate) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (predicate(array[index], index, array)) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.defaults` to customize its `_.assign` use.\n\t   *\n\t   * @private\n\t   * @param {*} objectValue The destination object property value.\n\t   * @param {*} sourceValue The source object property value.\n\t   * @returns {*} Returns the value to assign to the destination object.\n\t   */\n\t  function assignDefaults(objectValue, sourceValue) {\n\t    return objectValue === undefined ? sourceValue : objectValue;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.template` to customize its `_.assign` use.\n\t   *\n\t   * **Note:** This function is like `assignDefaults` except that it ignores\n\t   * inherited property values when checking if a property is `undefined`.\n\t   *\n\t   * @private\n\t   * @param {*} objectValue The destination object property value.\n\t   * @param {*} sourceValue The source object property value.\n\t   * @param {string} key The key associated with the object and source values.\n\t   * @param {Object} object The destination object.\n\t   * @returns {*} Returns the value to assign to the destination object.\n\t   */\n\t  function assignOwnDefaults(objectValue, sourceValue, key, object) {\n\t    return (objectValue === undefined || !hasOwnProperty.call(object, key))\n\t      ? sourceValue\n\t      : objectValue;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.assign` for customizing assigned values without\n\t   * support for argument juggling, multiple sources, and `this` binding `customizer`\n\t   * functions.\n\t   *\n\t   * @private\n\t   * @param {Object} object The destination object.\n\t   * @param {Object} source The source object.\n\t   * @param {Function} customizer The function to customize assigned values.\n\t   * @returns {Object} Returns `object`.\n\t   */\n\t  function assignWith(object, source, customizer) {\n\t    var index = -1,\n\t        props = keys(source),\n\t        length = props.length;\n\t\n\t    while (++index < length) {\n\t      var key = props[index],\n\t          value = object[key],\n\t          result = customizer(value, source[key], key, object, source);\n\t\n\t      if ((result === result ? (result !== value) : (value === value)) ||\n\t          (value === undefined && !(key in object))) {\n\t        object[key] = result;\n\t      }\n\t    }\n\t    return object;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.assign` without support for argument juggling,\n\t   * multiple sources, and `customizer` functions.\n\t   *\n\t   * @private\n\t   * @param {Object} object The destination object.\n\t   * @param {Object} source The source object.\n\t   * @returns {Object} Returns `object`.\n\t   */\n\t  function baseAssign(object, source) {\n\t    return source == null\n\t      ? object\n\t      : baseCopy(source, keys(source), object);\n\t  }\n\t\n\t  /**\n\t   * Copies properties of `source` to `object`.\n\t   *\n\t   * @private\n\t   * @param {Object} source The object to copy properties from.\n\t   * @param {Array} props The property names to copy.\n\t   * @param {Object} [object={}] The object to copy properties to.\n\t   * @returns {Object} Returns `object`.\n\t   */\n\t  function baseCopy(source, props, object) {\n\t    object || (object = {});\n\t\n\t    var index = -1,\n\t        length = props.length;\n\t\n\t    while (++index < length) {\n\t      var key = props[index];\n\t      object[key] = source[key];\n\t    }\n\t    return object;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.callback` which supports specifying the\n\t   * number of arguments to provide to `func`.\n\t   *\n\t   * @private\n\t   * @param {*} [func=_.identity] The value to convert to a callback.\n\t   * @param {*} [thisArg] The `this` binding of `func`.\n\t   * @param {number} [argCount] The number of arguments to provide to `func`.\n\t   * @returns {Function} Returns the callback.\n\t   */\n\t  function baseCallback(func, thisArg, argCount) {\n\t    var type = typeof func;\n\t    if (type == \'function\') {\n\t      return thisArg === undefined\n\t        ? func\n\t        : bindCallback(func, thisArg, argCount);\n\t    }\n\t    if (func == null) {\n\t      return identity;\n\t    }\n\t    if (type == \'object\') {\n\t      return baseMatches(func);\n\t    }\n\t    return thisArg === undefined\n\t      ? property(func)\n\t      : baseMatchesProperty(func, thisArg);\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.clone` without support for argument juggling\n\t   * and `this` binding `customizer` functions.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to clone.\n\t   * @param {boolean} [isDeep] Specify a deep clone.\n\t   * @param {Function} [customizer] The function to customize cloning values.\n\t   * @param {string} [key] The key of `value`.\n\t   * @param {Object} [object] The object `value` belongs to.\n\t   * @param {Array} [stackA=[]] Tracks traversed source objects.\n\t   * @param {Array} [stackB=[]] Associates clones with source counterparts.\n\t   * @returns {*} Returns the cloned value.\n\t   */\n\t  function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n\t    var result;\n\t    if (customizer) {\n\t      result = object ? customizer(value, key, object) : customizer(value);\n\t    }\n\t    if (result !== undefined) {\n\t      return result;\n\t    }\n\t    if (!isObject(value)) {\n\t      return value;\n\t    }\n\t    var isArr = isArray(value);\n\t    if (isArr) {\n\t      result = initCloneArray(value);\n\t      if (!isDeep) {\n\t        return arrayCopy(value, result);\n\t      }\n\t    } else {\n\t      var tag = objToString.call(value),\n\t          isFunc = tag == funcTag;\n\t\n\t      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n\t        result = initCloneObject(isFunc ? {} : value);\n\t        if (!isDeep) {\n\t          return baseAssign(result, value);\n\t        }\n\t      } else {\n\t        return cloneableTags[tag]\n\t          ? initCloneByTag(value, tag, isDeep)\n\t          : (object ? value : {});\n\t      }\n\t    }\n\t    // Check for circular references and return its corresponding clone.\n\t    stackA || (stackA = []);\n\t    stackB || (stackB = []);\n\t\n\t    var length = stackA.length;\n\t    while (length--) {\n\t      if (stackA[length] == value) {\n\t        return stackB[length];\n\t      }\n\t    }\n\t    // Add the source value to the stack of traversed objects and associate it with its clone.\n\t    stackA.push(value);\n\t    stackB.push(result);\n\t\n\t    // Recursively populate clone (susceptible to call stack limits).\n\t    (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n\t      result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.create` without support for assigning\n\t   * properties to the created object.\n\t   *\n\t   * @private\n\t   * @param {Object} prototype The object to inherit from.\n\t   * @returns {Object} Returns the new object.\n\t   */\n\t  var baseCreate = (function() {\n\t    function object() {}\n\t    return function(prototype) {\n\t      if (isObject(prototype)) {\n\t        object.prototype = prototype;\n\t        var result = new object;\n\t        object.prototype = undefined;\n\t      }\n\t      return result || {};\n\t    };\n\t  }());\n\t\n\t  /**\n\t   * The base implementation of `_.difference` which accepts a single array\n\t   * of values to exclude.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {Array} values The values to exclude.\n\t   * @returns {Array} Returns the new array of filtered values.\n\t   */\n\t  function baseDifference(array, values) {\n\t    var length = array ? array.length : 0,\n\t        result = [];\n\t\n\t    if (!length) {\n\t      return result;\n\t    }\n\t    var index = -1,\n\t        indexOf = getIndexOf(),\n\t        isCommon = indexOf === baseIndexOf,\n\t        cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,\n\t        valuesLength = values.length;\n\t\n\t    if (cache) {\n\t      indexOf = cacheIndexOf;\n\t      isCommon = false;\n\t      values = cache;\n\t    }\n\t    outer:\n\t    while (++index < length) {\n\t      var value = array[index];\n\t\n\t      if (isCommon && value === value) {\n\t        var valuesIndex = valuesLength;\n\t        while (valuesIndex--) {\n\t          if (values[valuesIndex] === value) {\n\t            continue outer;\n\t          }\n\t        }\n\t        result.push(value);\n\t      }\n\t      else if (indexOf(values, value, 0) < 0) {\n\t        result.push(value);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.forEach` without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array|Object|string} Returns `collection`.\n\t   */\n\t  var baseEach = createBaseEach(baseForOwn);\n\t\n\t  /**\n\t   * The base implementation of `_.every` without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t   *  else `false`\n\t   */\n\t  function baseEvery(collection, predicate) {\n\t    var result = true;\n\t    baseEach(collection, function(value, index, collection) {\n\t      result = !!predicate(value, index, collection);\n\t      return result;\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Gets the extremum value of `collection` invoking `iteratee` for each value\n\t   * in `collection` to generate the criterion by which the value is ranked.\n\t   * The `iteratee` is invoked with three arguments: (value, index|key, collection).\n\t   *\n\t   * @private\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {Function} comparator The function used to compare values.\n\t   * @param {*} exValue The initial extremum value.\n\t   * @returns {*} Returns the extremum value.\n\t   */\n\t  function baseExtremum(collection, iteratee, comparator, exValue) {\n\t    var computed = exValue,\n\t        result = computed;\n\t\n\t    baseEach(collection, function(value, index, collection) {\n\t      var current = +iteratee(value, index, collection);\n\t      if (comparator(current, computed) || (current === exValue && current === result)) {\n\t        computed = current;\n\t        result = value;\n\t      }\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.filter` without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {Array} Returns the new filtered array.\n\t   */\n\t  function baseFilter(collection, predicate) {\n\t    var result = [];\n\t    baseEach(collection, function(value, index, collection) {\n\t      if (predicate(value, index, collection)) {\n\t        result.push(value);\n\t      }\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n\t   * without support for callback shorthands and `this` binding, which iterates\n\t   * over `collection` using the provided `eachFunc`.\n\t   *\n\t   * @private\n\t   * @param {Array|Object|string} collection The collection to search.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @param {Function} eachFunc The function to iterate over `collection`.\n\t   * @param {boolean} [retKey] Specify returning the key of the found element\n\t   *  instead of the element itself.\n\t   * @returns {*} Returns the found element or its key, else `undefined`.\n\t   */\n\t  function baseFind(collection, predicate, eachFunc, retKey) {\n\t    var result;\n\t    eachFunc(collection, function(value, key, collection) {\n\t      if (predicate(value, key, collection)) {\n\t        result = retKey ? key : value;\n\t        return false;\n\t      }\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.flatten` with added support for restricting\n\t   * flattening and specifying the start index.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to flatten.\n\t   * @param {boolean} [isDeep] Specify a deep flatten.\n\t   * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.\n\t   * @param {Array} [result=[]] The initial result value.\n\t   * @returns {Array} Returns the new flattened array.\n\t   */\n\t  function baseFlatten(array, isDeep, isStrict, result) {\n\t    result || (result = []);\n\t\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      var value = array[index];\n\t      if (isObjectLike(value) && isArrayLike(value) &&\n\t          (isStrict || isArray(value) || isArguments(value))) {\n\t        if (isDeep) {\n\t          // Recursively flatten arrays (susceptible to call stack limits).\n\t          baseFlatten(value, isDeep, isStrict, result);\n\t        } else {\n\t          arrayPush(result, value);\n\t        }\n\t      } else if (!isStrict) {\n\t        result[result.length] = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `baseForIn` and `baseForOwn` which iterates\n\t   * over `object` properties returned by `keysFunc` invoking `iteratee` for\n\t   * each property. Iteratee functions may exit iteration early by explicitly\n\t   * returning `false`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {Function} keysFunc The function to get the keys of `object`.\n\t   * @returns {Object} Returns `object`.\n\t   */\n\t  var baseFor = createBaseFor();\n\t\n\t  /**\n\t   * The base implementation of `_.forIn` without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Object} Returns `object`.\n\t   */\n\t  function baseForIn(object, iteratee) {\n\t    return baseFor(object, iteratee, keysIn);\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.forOwn` without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Object} Returns `object`.\n\t   */\n\t  function baseForOwn(object, iteratee) {\n\t    return baseFor(object, iteratee, keys);\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.functions` which creates an array of\n\t   * `object` function property names filtered from those provided.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to inspect.\n\t   * @param {Array} props The property names to filter.\n\t   * @returns {Array} Returns the new array of filtered property names.\n\t   */\n\t  function baseFunctions(object, props) {\n\t    var index = -1,\n\t        length = props.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      var key = props[index];\n\t      if (isFunction(object[key])) {\n\t        result[++resIndex] = key;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `get` without support for string paths\n\t   * and default values.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @param {Array} path The path of the property to get.\n\t   * @param {string} [pathKey] The key representation of path.\n\t   * @returns {*} Returns the resolved value.\n\t   */\n\t  function baseGet(object, path, pathKey) {\n\t    if (object == null) {\n\t      return;\n\t    }\n\t    if (pathKey !== undefined && pathKey in toObject(object)) {\n\t      path = [pathKey];\n\t    }\n\t    var index = 0,\n\t        length = path.length;\n\t\n\t    while (object != null && index < length) {\n\t      object = object[path[index++]];\n\t    }\n\t    return (index && index == length) ? object : undefined;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.isEqual` without support for `this` binding\n\t   * `customizer` functions.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to compare.\n\t   * @param {*} other The other value to compare.\n\t   * @param {Function} [customizer] The function to customize comparing values.\n\t   * @param {boolean} [isLoose] Specify performing partial comparisons.\n\t   * @param {Array} [stackA] Tracks traversed `value` objects.\n\t   * @param {Array} [stackB] Tracks traversed `other` objects.\n\t   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t   */\n\t  function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n\t    if (value === other) {\n\t      return true;\n\t    }\n\t    if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n\t      return value !== value && other !== other;\n\t    }\n\t    return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `baseIsEqual` for arrays and objects which performs\n\t   * deep comparisons and tracks traversed objects enabling objects with circular\n\t   * references to be compared.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to compare.\n\t   * @param {Object} other The other object to compare.\n\t   * @param {Function} equalFunc The function to determine equivalents of values.\n\t   * @param {Function} [customizer] The function to customize comparing objects.\n\t   * @param {boolean} [isLoose] Specify performing partial comparisons.\n\t   * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n\t   * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n\t   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t   */\n\t  function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n\t    var objIsArr = isArray(object),\n\t        othIsArr = isArray(other),\n\t        objTag = arrayTag,\n\t        othTag = arrayTag;\n\t\n\t    if (!objIsArr) {\n\t      objTag = objToString.call(object);\n\t      if (objTag == argsTag) {\n\t        objTag = objectTag;\n\t      } else if (objTag != objectTag) {\n\t        objIsArr = isTypedArray(object);\n\t      }\n\t    }\n\t    if (!othIsArr) {\n\t      othTag = objToString.call(other);\n\t      if (othTag == argsTag) {\n\t        othTag = objectTag;\n\t      } else if (othTag != objectTag) {\n\t        othIsArr = isTypedArray(other);\n\t      }\n\t    }\n\t    var objIsObj = objTag == objectTag,\n\t        othIsObj = othTag == objectTag,\n\t        isSameTag = objTag == othTag;\n\t\n\t    if (isSameTag && !(objIsArr || objIsObj)) {\n\t      return equalByTag(object, other, objTag);\n\t    }\n\t    if (!isLoose) {\n\t      var objIsWrapped = objIsObj && hasOwnProperty.call(object, \'__wrapped__\'),\n\t          othIsWrapped = othIsObj && hasOwnProperty.call(other, \'__wrapped__\');\n\t\n\t      if (objIsWrapped || othIsWrapped) {\n\t        return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n\t      }\n\t    }\n\t    if (!isSameTag) {\n\t      return false;\n\t    }\n\t    // Assume cyclic values are equal.\n\t    // For more information on detecting circular references see https://es5.github.io/#JO.\n\t    stackA || (stackA = []);\n\t    stackB || (stackB = []);\n\t\n\t    var length = stackA.length;\n\t    while (length--) {\n\t      if (stackA[length] == object) {\n\t        return stackB[length] == other;\n\t      }\n\t    }\n\t    // Add `object` and `other` to the stack of traversed objects.\n\t    stackA.push(object);\n\t    stackB.push(other);\n\t\n\t    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\t\n\t    stackA.pop();\n\t    stackB.pop();\n\t\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.isMatch` without support for callback\n\t   * shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to inspect.\n\t   * @param {Array} matchData The propery names, values, and compare flags to match.\n\t   * @param {Function} [customizer] The function to customize comparing objects.\n\t   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t   */\n\t  function baseIsMatch(object, matchData, customizer) {\n\t    var index = matchData.length,\n\t        length = index,\n\t        noCustomizer = !customizer;\n\t\n\t    if (object == null) {\n\t      return !length;\n\t    }\n\t    object = toObject(object);\n\t    while (index--) {\n\t      var data = matchData[index];\n\t      if ((noCustomizer && data[2])\n\t            ? data[1] !== object[data[0]]\n\t            : !(data[0] in object)\n\t          ) {\n\t        return false;\n\t      }\n\t    }\n\t    while (++index < length) {\n\t      data = matchData[index];\n\t      var key = data[0],\n\t          objValue = object[key],\n\t          srcValue = data[1];\n\t\n\t      if (noCustomizer && data[2]) {\n\t        if (objValue === undefined && !(key in object)) {\n\t          return false;\n\t        }\n\t      } else {\n\t        var result = customizer ? customizer(objValue, srcValue, key) : undefined;\n\t        if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {\n\t          return false;\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.map` without support for callback shorthands\n\t   * and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns the new mapped array.\n\t   */\n\t  function baseMap(collection, iteratee) {\n\t    var index = -1,\n\t        result = isArrayLike(collection) ? Array(collection.length) : [];\n\t\n\t    baseEach(collection, function(value, key, collection) {\n\t      result[++index] = iteratee(value, key, collection);\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.matches` which does not clone `source`.\n\t   *\n\t   * @private\n\t   * @param {Object} source The object of property values to match.\n\t   * @returns {Function} Returns the new function.\n\t   */\n\t  function baseMatches(source) {\n\t    var matchData = getMatchData(source);\n\t    if (matchData.length == 1 && matchData[0][2]) {\n\t      var key = matchData[0][0],\n\t          value = matchData[0][1];\n\t\n\t      return function(object) {\n\t        if (object == null) {\n\t          return false;\n\t        }\n\t        return object[key] === value && (value !== undefined || (key in toObject(object)));\n\t      };\n\t    }\n\t    return function(object) {\n\t      return baseIsMatch(object, matchData);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.matchesProperty` which does not clone `srcValue`.\n\t   *\n\t   * @private\n\t   * @param {string} path The path of the property to get.\n\t   * @param {*} srcValue The value to compare.\n\t   * @returns {Function} Returns the new function.\n\t   */\n\t  function baseMatchesProperty(path, srcValue) {\n\t    var isArr = isArray(path),\n\t        isCommon = isKey(path) && isStrictComparable(srcValue),\n\t        pathKey = (path + \'\');\n\t\n\t    path = toPath(path);\n\t    return function(object) {\n\t      if (object == null) {\n\t        return false;\n\t      }\n\t      var key = pathKey;\n\t      object = toObject(object);\n\t      if ((isArr || !isCommon) && !(key in object)) {\n\t        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n\t        if (object == null) {\n\t          return false;\n\t        }\n\t        key = last(path);\n\t        object = toObject(object);\n\t      }\n\t      return object[key] === srcValue\n\t        ? (srcValue !== undefined || (key in object))\n\t        : baseIsEqual(srcValue, object[key], undefined, true);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.merge` without support for argument juggling,\n\t   * multiple sources, and `this` binding `customizer` functions.\n\t   *\n\t   * @private\n\t   * @param {Object} object The destination object.\n\t   * @param {Object} source The source object.\n\t   * @param {Function} [customizer] The function to customize merged values.\n\t   * @param {Array} [stackA=[]] Tracks traversed source objects.\n\t   * @param {Array} [stackB=[]] Associates values with source counterparts.\n\t   * @returns {Object} Returns `object`.\n\t   */\n\t  function baseMerge(object, source, customizer, stackA, stackB) {\n\t    if (!isObject(object)) {\n\t      return object;\n\t    }\n\t    var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\n\t        props = isSrcArr ? undefined : keys(source);\n\t\n\t    arrayEach(props || source, function(srcValue, key) {\n\t      if (props) {\n\t        key = srcValue;\n\t        srcValue = source[key];\n\t      }\n\t      if (isObjectLike(srcValue)) {\n\t        stackA || (stackA = []);\n\t        stackB || (stackB = []);\n\t        baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n\t      }\n\t      else {\n\t        var value = object[key],\n\t            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n\t            isCommon = result === undefined;\n\t\n\t        if (isCommon) {\n\t          result = srcValue;\n\t        }\n\t        if ((result !== undefined || (isSrcArr && !(key in object))) &&\n\t            (isCommon || (result === result ? (result !== value) : (value === value)))) {\n\t          object[key] = result;\n\t        }\n\t      }\n\t    });\n\t    return object;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `baseMerge` for arrays and objects which performs\n\t   * deep merges and tracks traversed objects enabling objects with circular\n\t   * references to be merged.\n\t   *\n\t   * @private\n\t   * @param {Object} object The destination object.\n\t   * @param {Object} source The source object.\n\t   * @param {string} key The key of the value to merge.\n\t   * @param {Function} mergeFunc The function to merge values.\n\t   * @param {Function} [customizer] The function to customize merged values.\n\t   * @param {Array} [stackA=[]] Tracks traversed source objects.\n\t   * @param {Array} [stackB=[]] Associates values with source counterparts.\n\t   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t   */\n\t  function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n\t    var length = stackA.length,\n\t        srcValue = source[key];\n\t\n\t    while (length--) {\n\t      if (stackA[length] == srcValue) {\n\t        object[key] = stackB[length];\n\t        return;\n\t      }\n\t    }\n\t    var value = object[key],\n\t        result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n\t        isCommon = result === undefined;\n\t\n\t    if (isCommon) {\n\t      result = srcValue;\n\t      if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n\t        result = isArray(value)\n\t          ? value\n\t          : (isArrayLike(value) ? arrayCopy(value) : []);\n\t      }\n\t      else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n\t        result = isArguments(value)\n\t          ? toPlainObject(value)\n\t          : (isPlainObject(value) ? value : {});\n\t      }\n\t      else {\n\t        isCommon = false;\n\t      }\n\t    }\n\t    // Add the source value to the stack of traversed objects and associate\n\t    // it with its merged value.\n\t    stackA.push(srcValue);\n\t    stackB.push(result);\n\t\n\t    if (isCommon) {\n\t      // Recursively merge objects and arrays (susceptible to call stack limits).\n\t      object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n\t    } else if (result === result ? (result !== value) : (value === value)) {\n\t      object[key] = result;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.property` without support for deep paths.\n\t   *\n\t   * @private\n\t   * @param {string} key The key of the property to get.\n\t   * @returns {Function} Returns the new function.\n\t   */\n\t  function baseProperty(key) {\n\t    return function(object) {\n\t      return object == null ? undefined : object[key];\n\t    };\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `baseProperty` which supports deep paths.\n\t   *\n\t   * @private\n\t   * @param {Array|string} path The path of the property to get.\n\t   * @returns {Function} Returns the new function.\n\t   */\n\t  function basePropertyDeep(path) {\n\t    var pathKey = (path + \'\');\n\t    path = toPath(path);\n\t    return function(object) {\n\t      return baseGet(object, path, pathKey);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.pullAt` without support for individual\n\t   * index arguments and capturing the removed elements.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to modify.\n\t   * @param {number[]} indexes The indexes of elements to remove.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function basePullAt(array, indexes) {\n\t    var length = array ? indexes.length : 0;\n\t    while (length--) {\n\t      var index = indexes[length];\n\t      if (index != previous && isIndex(index)) {\n\t        var previous = index;\n\t        splice.call(array, index, 1);\n\t      }\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.random` without support for argument juggling\n\t   * and returning floating-point numbers.\n\t   *\n\t   * @private\n\t   * @param {number} min The minimum possible value.\n\t   * @param {number} max The maximum possible value.\n\t   * @returns {number} Returns the random number.\n\t   */\n\t  function baseRandom(min, max) {\n\t    return min + nativeFloor(nativeRandom() * (max - min + 1));\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.reduce` and `_.reduceRight` without support\n\t   * for callback shorthands and `this` binding, which iterates over `collection`\n\t   * using the provided `eachFunc`.\n\t   *\n\t   * @private\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {*} accumulator The initial value.\n\t   * @param {boolean} initFromCollection Specify using the first or last element\n\t   *  of `collection` as the initial value.\n\t   * @param {Function} eachFunc The function to iterate over `collection`.\n\t   * @returns {*} Returns the accumulated value.\n\t   */\n\t  function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n\t    eachFunc(collection, function(value, index, collection) {\n\t      accumulator = initFromCollection\n\t        ? (initFromCollection = false, value)\n\t        : iteratee(accumulator, value, index, collection);\n\t    });\n\t    return accumulator;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `setData` without support for hot loop detection.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to associate metadata with.\n\t   * @param {*} data The metadata.\n\t   * @returns {Function} Returns `func`.\n\t   */\n\t  var baseSetData = !metaMap ? identity : function(func, data) {\n\t    metaMap.set(func, data);\n\t    return func;\n\t  };\n\t\n\t  /**\n\t   * The base implementation of `_.slice` without an iteratee call guard.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to slice.\n\t   * @param {number} [start=0] The start position.\n\t   * @param {number} [end=array.length] The end position.\n\t   * @returns {Array} Returns the slice of `array`.\n\t   */\n\t  function baseSlice(array, start, end) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    start = start == null ? 0 : (+start || 0);\n\t    if (start < 0) {\n\t      start = -start > length ? 0 : (length + start);\n\t    }\n\t    end = (end === undefined || end > length) ? length : (+end || 0);\n\t    if (end < 0) {\n\t      end += length;\n\t    }\n\t    length = start > end ? 0 : ((end - start) >>> 0);\n\t    start >>>= 0;\n\t\n\t    var result = Array(length);\n\t    while (++index < length) {\n\t      result[index] = array[index + start];\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.some` without support for callback shorthands\n\t   * and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t   *  else `false`.\n\t   */\n\t  function baseSome(collection, predicate) {\n\t    var result;\n\t\n\t    baseEach(collection, function(value, index, collection) {\n\t      result = predicate(value, index, collection);\n\t      return !result;\n\t    });\n\t    return !!result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.sortBy` which uses `comparer` to define\n\t   * the sort order of `array` and replaces criteria objects with their\n\t   * corresponding values.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to sort.\n\t   * @param {Function} comparer The function to define sort order.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function baseSortBy(array, comparer) {\n\t    var length = array.length;\n\t\n\t    array.sort(comparer);\n\t    while (length--) {\n\t      array[length] = array[length].value;\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.uniq` without support for callback shorthands\n\t   * and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {Function} [iteratee] The function invoked per iteration.\n\t   * @returns {Array} Returns the new duplicate free array.\n\t   */\n\t  function baseUniq(array, iteratee) {\n\t    var index = -1,\n\t        indexOf = getIndexOf(),\n\t        length = array.length,\n\t        isCommon = indexOf === baseIndexOf,\n\t        isLarge = isCommon && length >= LARGE_ARRAY_SIZE,\n\t        seen = isLarge ? createCache() : null,\n\t        result = [];\n\t\n\t    if (seen) {\n\t      indexOf = cacheIndexOf;\n\t      isCommon = false;\n\t    } else {\n\t      isLarge = false;\n\t      seen = iteratee ? [] : result;\n\t    }\n\t    outer:\n\t    while (++index < length) {\n\t      var value = array[index],\n\t          computed = iteratee ? iteratee(value, index, array) : value;\n\t\n\t      if (isCommon && value === value) {\n\t        var seenIndex = seen.length;\n\t        while (seenIndex--) {\n\t          if (seen[seenIndex] === computed) {\n\t            continue outer;\n\t          }\n\t        }\n\t        if (iteratee) {\n\t          seen.push(computed);\n\t        }\n\t        result.push(value);\n\t      }\n\t      else if (indexOf(seen, computed, 0) < 0) {\n\t        if (iteratee || isLarge) {\n\t          seen.push(computed);\n\t        }\n\t        result.push(value);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.values` and `_.valuesIn` which creates an\n\t   * array of `object` property values corresponding to the property names\n\t   * of `props`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @param {Array} props The property names to get values for.\n\t   * @returns {Object} Returns the array of property values.\n\t   */\n\t  function baseValues(object, props) {\n\t    var index = -1,\n\t        length = props.length,\n\t        result = Array(length);\n\t\n\t    while (++index < length) {\n\t      result[index] = object[props[index]];\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Performs a binary search of `array` to determine the index at which `value`\n\t   * should be inserted into `array` in order to maintain its sort order.\n\t   *\n\t   * @private\n\t   * @param {Array} array The sorted array to inspect.\n\t   * @param {*} value The value to evaluate.\n\t   * @param {boolean} [retHighest] Specify returning the highest qualified index.\n\t   * @returns {number} Returns the index at which `value` should be inserted\n\t   *  into `array`.\n\t   */\n\t  function binaryIndex(array, value, retHighest) {\n\t    var low = 0,\n\t        high = array ? array.length : low;\n\t\n\t    if (typeof value == \'number\' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n\t      while (low < high) {\n\t        var mid = (low + high) >>> 1,\n\t            computed = array[mid];\n\t\n\t        if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {\n\t          low = mid + 1;\n\t        } else {\n\t          high = mid;\n\t        }\n\t      }\n\t      return high;\n\t    }\n\t    return binaryIndexBy(array, value, identity, retHighest);\n\t  }\n\t\n\t  /**\n\t   * This function is like `binaryIndex` except that it invokes `iteratee` for\n\t   * `value` and each element of `array` to compute their sort ranking. The\n\t   * iteratee is invoked with one argument; (value).\n\t   *\n\t   * @private\n\t   * @param {Array} array The sorted array to inspect.\n\t   * @param {*} value The value to evaluate.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {boolean} [retHighest] Specify returning the highest qualified index.\n\t   * @returns {number} Returns the index at which `value` should be inserted\n\t   *  into `array`.\n\t   */\n\t  function binaryIndexBy(array, value, iteratee, retHighest) {\n\t    value = iteratee(value);\n\t\n\t    var low = 0,\n\t        high = array ? array.length : 0,\n\t        valIsNaN = value !== value,\n\t        valIsNull = value === null,\n\t        valIsUndef = value === undefined;\n\t\n\t    while (low < high) {\n\t      var mid = nativeFloor((low + high) / 2),\n\t          computed = iteratee(array[mid]),\n\t          isDef = computed !== undefined,\n\t          isReflexive = computed === computed;\n\t\n\t      if (valIsNaN) {\n\t        var setLow = isReflexive || retHighest;\n\t      } else if (valIsNull) {\n\t        setLow = isReflexive && isDef && (retHighest || computed != null);\n\t      } else if (valIsUndef) {\n\t        setLow = isReflexive && (retHighest || isDef);\n\t      } else if (computed == null) {\n\t        setLow = false;\n\t      } else {\n\t        setLow = retHighest ? (computed <= value) : (computed < value);\n\t      }\n\t      if (setLow) {\n\t        low = mid + 1;\n\t      } else {\n\t        high = mid;\n\t      }\n\t    }\n\t    return nativeMin(high, MAX_ARRAY_INDEX);\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `baseCallback` which only supports `this` binding\n\t   * and specifying the number of arguments to provide to `func`.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to bind.\n\t   * @param {*} thisArg The `this` binding of `func`.\n\t   * @param {number} [argCount] The number of arguments to provide to `func`.\n\t   * @returns {Function} Returns the callback.\n\t   */\n\t  function bindCallback(func, thisArg, argCount) {\n\t    if (typeof func != \'function\') {\n\t      return identity;\n\t    }\n\t    if (thisArg === undefined) {\n\t      return func;\n\t    }\n\t    switch (argCount) {\n\t      case 1: return function(value) {\n\t        return func.call(thisArg, value);\n\t      };\n\t      case 3: return function(value, index, collection) {\n\t        return func.call(thisArg, value, index, collection);\n\t      };\n\t      case 4: return function(accumulator, value, index, collection) {\n\t        return func.call(thisArg, accumulator, value, index, collection);\n\t      };\n\t      case 5: return function(value, other, key, object, source) {\n\t        return func.call(thisArg, value, other, key, object, source);\n\t      };\n\t    }\n\t    return function() {\n\t      return func.apply(thisArg, arguments);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a clone of the given array buffer.\n\t   *\n\t   * @private\n\t   * @param {ArrayBuffer} buffer The array buffer to clone.\n\t   * @returns {ArrayBuffer} Returns the cloned array buffer.\n\t   */\n\t  function bufferClone(buffer) {\n\t    var result = new ArrayBuffer(buffer.byteLength),\n\t        view = new Uint8Array(result);\n\t\n\t    view.set(new Uint8Array(buffer));\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Creates an array that is the composition of partially applied arguments,\n\t   * placeholders, and provided arguments into a single array of arguments.\n\t   *\n\t   * @private\n\t   * @param {Array|Object} args The provided arguments.\n\t   * @param {Array} partials The arguments to prepend to those provided.\n\t   * @param {Array} holders The `partials` placeholder indexes.\n\t   * @returns {Array} Returns the new array of composed arguments.\n\t   */\n\t  function composeArgs(args, partials, holders) {\n\t    var holdersLength = holders.length,\n\t        argsIndex = -1,\n\t        argsLength = nativeMax(args.length - holdersLength, 0),\n\t        leftIndex = -1,\n\t        leftLength = partials.length,\n\t        result = Array(leftLength + argsLength);\n\t\n\t    while (++leftIndex < leftLength) {\n\t      result[leftIndex] = partials[leftIndex];\n\t    }\n\t    while (++argsIndex < holdersLength) {\n\t      result[holders[argsIndex]] = args[argsIndex];\n\t    }\n\t    while (argsLength--) {\n\t      result[leftIndex++] = args[argsIndex++];\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * This function is like `composeArgs` except that the arguments composition\n\t   * is tailored for `_.partialRight`.\n\t   *\n\t   * @private\n\t   * @param {Array|Object} args The provided arguments.\n\t   * @param {Array} partials The arguments to append to those provided.\n\t   * @param {Array} holders The `partials` placeholder indexes.\n\t   * @returns {Array} Returns the new array of composed arguments.\n\t   */\n\t  function composeArgsRight(args, partials, holders) {\n\t    var holdersIndex = -1,\n\t        holdersLength = holders.length,\n\t        argsIndex = -1,\n\t        argsLength = nativeMax(args.length - holdersLength, 0),\n\t        rightIndex = -1,\n\t        rightLength = partials.length,\n\t        result = Array(argsLength + rightLength);\n\t\n\t    while (++argsIndex < argsLength) {\n\t      result[argsIndex] = args[argsIndex];\n\t    }\n\t    var offset = argsIndex;\n\t    while (++rightIndex < rightLength) {\n\t      result[offset + rightIndex] = partials[rightIndex];\n\t    }\n\t    while (++holdersIndex < holdersLength) {\n\t      result[offset + holders[holdersIndex]] = args[argsIndex++];\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.\n\t   *\n\t   * @private\n\t   * @param {Function} setter The function to set keys and values of the accumulator object.\n\t   * @param {Function} [initializer] The function to initialize the accumulator object.\n\t   * @returns {Function} Returns the new aggregator function.\n\t   */\n\t  function createAggregator(setter, initializer) {\n\t    return function(collection, iteratee, thisArg) {\n\t      var result = initializer ? initializer() : {};\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t\n\t      if (isArray(collection)) {\n\t        var index = -1,\n\t            length = collection.length;\n\t\n\t        while (++index < length) {\n\t          var value = collection[index];\n\t          setter(result, value, iteratee(value, index, collection), collection);\n\t        }\n\t      } else {\n\t        baseEach(collection, function(value, key, collection) {\n\t          setter(result, value, iteratee(value, key, collection), collection);\n\t        });\n\t      }\n\t      return result;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\n\t   *\n\t   * @private\n\t   * @param {Function} assigner The function to assign values.\n\t   * @returns {Function} Returns the new assigner function.\n\t   */\n\t  function createAssigner(assigner) {\n\t    return restParam(function(object, sources) {\n\t      var index = -1,\n\t          length = object == null ? 0 : sources.length,\n\t          customizer = length > 2 ? sources[length - 2] : undefined,\n\t          guard = length > 2 ? sources[2] : undefined,\n\t          thisArg = length > 1 ? sources[length - 1] : undefined;\n\t\n\t      if (typeof customizer == \'function\') {\n\t        customizer = bindCallback(customizer, thisArg, 5);\n\t        length -= 2;\n\t      } else {\n\t        customizer = typeof thisArg == \'function\' ? thisArg : undefined;\n\t        length -= (customizer ? 1 : 0);\n\t      }\n\t      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t        customizer = length < 3 ? undefined : customizer;\n\t        length = 1;\n\t      }\n\t      while (++index < length) {\n\t        var source = sources[index];\n\t        if (source) {\n\t          assigner(object, source, customizer);\n\t        }\n\t      }\n\t      return object;\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Creates a `baseEach` or `baseEachRight` function.\n\t   *\n\t   * @private\n\t   * @param {Function} eachFunc The function to iterate over a collection.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {Function} Returns the new base function.\n\t   */\n\t  function createBaseEach(eachFunc, fromRight) {\n\t    return function(collection, iteratee) {\n\t      var length = collection ? getLength(collection) : 0;\n\t      if (!isLength(length)) {\n\t        return eachFunc(collection, iteratee);\n\t      }\n\t      var index = fromRight ? length : -1,\n\t          iterable = toObject(collection);\n\t\n\t      while ((fromRight ? index-- : ++index < length)) {\n\t        if (iteratee(iterable[index], index, iterable) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return collection;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a base function for `_.forIn` or `_.forInRight`.\n\t   *\n\t   * @private\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {Function} Returns the new base function.\n\t   */\n\t  function createBaseFor(fromRight) {\n\t    return function(object, iteratee, keysFunc) {\n\t      var iterable = toObject(object),\n\t          props = keysFunc(object),\n\t          length = props.length,\n\t          index = fromRight ? length : -1;\n\t\n\t      while ((fromRight ? index-- : ++index < length)) {\n\t        var key = props[index];\n\t        if (iteratee(iterable[key], key, iterable) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return object;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a function that wraps `func` and invokes it with the `this`\n\t   * binding of `thisArg`.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to bind.\n\t   * @param {*} [thisArg] The `this` binding of `func`.\n\t   * @returns {Function} Returns the new bound function.\n\t   */\n\t  function createBindWrapper(func, thisArg) {\n\t    var Ctor = createCtorWrapper(func);\n\t\n\t    function wrapper() {\n\t      var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\t      return fn.apply(thisArg, arguments);\n\t    }\n\t    return wrapper;\n\t  }\n\t\n\t  /**\n\t   * Creates a `Set` cache object to optimize linear searches of large arrays.\n\t   *\n\t   * @private\n\t   * @param {Array} [values] The values to cache.\n\t   * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\n\t   */\n\t  function createCache(values) {\n\t    return (nativeCreate && Set) ? new SetCache(values) : null;\n\t  }\n\t\n\t  /**\n\t   * Creates a function that produces an instance of `Ctor` regardless of\n\t   * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n\t   *\n\t   * @private\n\t   * @param {Function} Ctor The constructor to wrap.\n\t   * @returns {Function} Returns the new wrapped function.\n\t   */\n\t  function createCtorWrapper(Ctor) {\n\t    return function() {\n\t      // Use a `switch` statement to work with class constructors.\n\t      // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n\t      // for more details.\n\t      var args = arguments;\n\t      switch (args.length) {\n\t        case 0: return new Ctor;\n\t        case 1: return new Ctor(args[0]);\n\t        case 2: return new Ctor(args[0], args[1]);\n\t        case 3: return new Ctor(args[0], args[1], args[2]);\n\t        case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n\t        case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n\t        case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n\t        case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n\t      }\n\t      var thisBinding = baseCreate(Ctor.prototype),\n\t          result = Ctor.apply(thisBinding, args);\n\t\n\t      // Mimic the constructor\'s `return` behavior.\n\t      // See https://es5.github.io/#x13.2.2 for more details.\n\t      return isObject(result) ? result : thisBinding;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a `_.defaults` or `_.defaultsDeep` function.\n\t   *\n\t   * @private\n\t   * @param {Function} assigner The function to assign values.\n\t   * @param {Function} customizer The function to customize assigned values.\n\t   * @returns {Function} Returns the new defaults function.\n\t   */\n\t  function createDefaults(assigner, customizer) {\n\t    return restParam(function(args) {\n\t      var object = args[0];\n\t      if (object == null) {\n\t        return object;\n\t      }\n\t      args.push(customizer);\n\t      return assigner.apply(undefined, args);\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Creates a `_.max` or `_.min` function.\n\t   *\n\t   * @private\n\t   * @param {Function} comparator The function used to compare values.\n\t   * @param {*} exValue The initial extremum value.\n\t   * @returns {Function} Returns the new extremum function.\n\t   */\n\t  function createExtremum(comparator, exValue) {\n\t    return function(collection, iteratee, thisArg) {\n\t      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n\t        iteratee = undefined;\n\t      }\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t      if (iteratee.length == 1) {\n\t        collection = isArray(collection) ? collection : toIterable(collection);\n\t        var result = arrayExtremum(collection, iteratee, comparator, exValue);\n\t        if (!(collection.length && result === exValue)) {\n\t          return result;\n\t        }\n\t      }\n\t      return baseExtremum(collection, iteratee, comparator, exValue);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a `_.find` or `_.findLast` function.\n\t   *\n\t   * @private\n\t   * @param {Function} eachFunc The function to iterate over a collection.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {Function} Returns the new find function.\n\t   */\n\t  function createFind(eachFunc, fromRight) {\n\t    return function(collection, predicate, thisArg) {\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      if (isArray(collection)) {\n\t        var index = baseFindIndex(collection, predicate, fromRight);\n\t        return index > -1 ? collection[index] : undefined;\n\t      }\n\t      return baseFind(collection, predicate, eachFunc);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a function for `_.forEach` or `_.forEachRight`.\n\t   *\n\t   * @private\n\t   * @param {Function} arrayFunc The function to iterate over an array.\n\t   * @param {Function} eachFunc The function to iterate over a collection.\n\t   * @returns {Function} Returns the new each function.\n\t   */\n\t  function createForEach(arrayFunc, eachFunc) {\n\t    return function(collection, iteratee, thisArg) {\n\t      return (typeof iteratee == \'function\' && thisArg === undefined && isArray(collection))\n\t        ? arrayFunc(collection, iteratee)\n\t        : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a function for `_.forOwn` or `_.forOwnRight`.\n\t   *\n\t   * @private\n\t   * @param {Function} objectFunc The function to iterate over an object.\n\t   * @returns {Function} Returns the new each function.\n\t   */\n\t  function createForOwn(objectFunc) {\n\t    return function(object, iteratee, thisArg) {\n\t      if (typeof iteratee != \'function\' || thisArg !== undefined) {\n\t        iteratee = bindCallback(iteratee, thisArg, 3);\n\t      }\n\t      return objectFunc(object, iteratee);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a function for `_.mapKeys` or `_.mapValues`.\n\t   *\n\t   * @private\n\t   * @param {boolean} [isMapKeys] Specify mapping keys instead of values.\n\t   * @returns {Function} Returns the new map function.\n\t   */\n\t  function createObjectMapper(isMapKeys) {\n\t    return function(object, iteratee, thisArg) {\n\t      var result = {};\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t\n\t      baseForOwn(object, function(value, key, object) {\n\t        var mapped = iteratee(value, key, object);\n\t        key = isMapKeys ? mapped : key;\n\t        value = isMapKeys ? value : mapped;\n\t        result[key] = value;\n\t      });\n\t      return result;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a function for `_.padLeft` or `_.padRight`.\n\t   *\n\t   * @private\n\t   * @param {boolean} [fromRight] Specify padding from the right.\n\t   * @returns {Function} Returns the new pad function.\n\t   */\n\t  function createPadDir(fromRight) {\n\t    return function(string, length, chars) {\n\t      string = baseToString(string);\n\t      return (fromRight ? string : \'\') + createPadding(string, length, chars) + (fromRight ? \'\' : string);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a function for `_.reduce` or `_.reduceRight`.\n\t   *\n\t   * @private\n\t   * @param {Function} arrayFunc The function to iterate over an array.\n\t   * @param {Function} eachFunc The function to iterate over a collection.\n\t   * @returns {Function} Returns the new each function.\n\t   */\n\t  function createReduce(arrayFunc, eachFunc) {\n\t    return function(collection, iteratee, accumulator, thisArg) {\n\t      var initFromArray = arguments.length < 3;\n\t      return (typeof iteratee == \'function\' && thisArg === undefined && isArray(collection))\n\t        ? arrayFunc(collection, iteratee, accumulator, initFromArray)\n\t        : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a function that wraps `func` and invokes it with optional `this`\n\t   * binding of, partial application, and currying.\n\t   *\n\t   * @private\n\t   * @param {Function|string} func The function or method name to reference.\n\t   * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n\t   * @param {*} [thisArg] The `this` binding of `func`.\n\t   * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n\t   * @param {Array} [holders] The `partials` placeholder indexes.\n\t   * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n\t   * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n\t   * @param {Array} [argPos] The argument positions of the new function.\n\t   * @param {number} [ary] The arity cap of `func`.\n\t   * @param {number} [arity] The arity of `func`.\n\t   * @returns {Function} Returns the new wrapped function.\n\t   */\n\t  function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n\t    var isAry = bitmask & ARY_FLAG,\n\t        isBind = bitmask & BIND_FLAG,\n\t        isBindKey = bitmask & BIND_KEY_FLAG,\n\t        isCurry = bitmask & CURRY_FLAG,\n\t        isCurryBound = bitmask & CURRY_BOUND_FLAG,\n\t        isCurryRight = bitmask & CURRY_RIGHT_FLAG,\n\t        Ctor = isBindKey ? undefined : createCtorWrapper(func);\n\t\n\t    function wrapper() {\n\t      // Avoid `arguments` object use disqualifying optimizations by\n\t      // converting it to an array before providing it to other functions.\n\t      var length = arguments.length,\n\t          index = length,\n\t          args = Array(length);\n\t\n\t      while (index--) {\n\t        args[index] = arguments[index];\n\t      }\n\t      if (partials) {\n\t        args = composeArgs(args, partials, holders);\n\t      }\n\t      if (partialsRight) {\n\t        args = composeArgsRight(args, partialsRight, holdersRight);\n\t      }\n\t      if (isCurry || isCurryRight) {\n\t        var placeholder = wrapper.placeholder,\n\t            argsHolders = replaceHolders(args, placeholder);\n\t\n\t        length -= argsHolders.length;\n\t        if (length < arity) {\n\t          var newArgPos = argPos ? arrayCopy(argPos) : undefined,\n\t              newArity = nativeMax(arity - length, 0),\n\t              newsHolders = isCurry ? argsHolders : undefined,\n\t              newHoldersRight = isCurry ? undefined : argsHolders,\n\t              newPartials = isCurry ? args : undefined,\n\t              newPartialsRight = isCurry ? undefined : args;\n\t\n\t          bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n\t          bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\t\n\t          if (!isCurryBound) {\n\t            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n\t          }\n\t          var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],\n\t              result = createHybridWrapper.apply(undefined, newData);\n\t\n\t          if (isLaziable(func)) {\n\t            setData(result, newData);\n\t          }\n\t          result.placeholder = placeholder;\n\t          return result;\n\t        }\n\t      }\n\t      var thisBinding = isBind ? thisArg : this,\n\t          fn = isBindKey ? thisBinding[func] : func;\n\t\n\t      if (argPos) {\n\t        args = reorder(args, argPos);\n\t      }\n\t      if (isAry && ary < args.length) {\n\t        args.length = ary;\n\t      }\n\t      if (this && this !== root && this instanceof wrapper) {\n\t        fn = Ctor || createCtorWrapper(func);\n\t      }\n\t      return fn.apply(thisBinding, args);\n\t    }\n\t    return wrapper;\n\t  }\n\t\n\t  /**\n\t   * Creates the padding required for `string` based on the given `length`.\n\t   * The `chars` string is truncated if the number of characters exceeds `length`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to create padding for.\n\t   * @param {number} [length=0] The padding length.\n\t   * @param {string} [chars=\' \'] The string used as padding.\n\t   * @returns {string} Returns the pad for `string`.\n\t   */\n\t  function createPadding(string, length, chars) {\n\t    var strLength = string.length;\n\t    length = +length;\n\t\n\t    if (strLength >= length || !nativeIsFinite(length)) {\n\t      return \'\';\n\t    }\n\t    var padLength = length - strLength;\n\t    chars = chars == null ? \' \' : (chars + \'\');\n\t    return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);\n\t  }\n\t\n\t  /**\n\t   * Creates a function that wraps `func` and invokes it with the optional `this`\n\t   * binding of `thisArg` and the `partials` prepended to those provided to\n\t   * the wrapper.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to partially apply arguments to.\n\t   * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n\t   * @param {*} thisArg The `this` binding of `func`.\n\t   * @param {Array} partials The arguments to prepend to those provided to the new function.\n\t   * @returns {Function} Returns the new bound function.\n\t   */\n\t  function createPartialWrapper(func, bitmask, thisArg, partials) {\n\t    var isBind = bitmask & BIND_FLAG,\n\t        Ctor = createCtorWrapper(func);\n\t\n\t    function wrapper() {\n\t      // Avoid `arguments` object use disqualifying optimizations by\n\t      // converting it to an array before providing it `func`.\n\t      var argsIndex = -1,\n\t          argsLength = arguments.length,\n\t          leftIndex = -1,\n\t          leftLength = partials.length,\n\t          args = Array(leftLength + argsLength);\n\t\n\t      while (++leftIndex < leftLength) {\n\t        args[leftIndex] = partials[leftIndex];\n\t      }\n\t      while (argsLength--) {\n\t        args[leftIndex++] = arguments[++argsIndex];\n\t      }\n\t      var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\t      return fn.apply(isBind ? thisArg : this, args);\n\t    }\n\t    return wrapper;\n\t  }\n\t\n\t  /**\n\t   * Creates a function that either curries or invokes `func` with optional\n\t   * `this` binding and partially applied arguments.\n\t   *\n\t   * @private\n\t   * @param {Function|string} func The function or method name to reference.\n\t   * @param {number} bitmask The bitmask of flags.\n\t   *  The bitmask may be composed of the following flags:\n\t   *     1 - `_.bind`\n\t   *     2 - `_.bindKey`\n\t   *     4 - `_.curry` or `_.curryRight` of a bound function\n\t   *     8 - `_.curry`\n\t   *    16 - `_.curryRight`\n\t   *    32 - `_.partial`\n\t   *    64 - `_.partialRight`\n\t   *   128 - `_.rearg`\n\t   *   256 - `_.ary`\n\t   * @param {*} [thisArg] The `this` binding of `func`.\n\t   * @param {Array} [partials] The arguments to be partially applied.\n\t   * @param {Array} [holders] The `partials` placeholder indexes.\n\t   * @param {Array} [argPos] The argument positions of the new function.\n\t   * @param {number} [ary] The arity cap of `func`.\n\t   * @param {number} [arity] The arity of `func`.\n\t   * @returns {Function} Returns the new wrapped function.\n\t   */\n\t  function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n\t    var isBindKey = bitmask & BIND_KEY_FLAG;\n\t    if (!isBindKey && typeof func != \'function\') {\n\t      throw new TypeError(FUNC_ERROR_TEXT);\n\t    }\n\t    var length = partials ? partials.length : 0;\n\t    if (!length) {\n\t      bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n\t      partials = holders = undefined;\n\t    }\n\t    length -= (holders ? holders.length : 0);\n\t    if (bitmask & PARTIAL_RIGHT_FLAG) {\n\t      var partialsRight = partials,\n\t          holdersRight = holders;\n\t\n\t      partials = holders = undefined;\n\t    }\n\t    var data = isBindKey ? undefined : getData(func),\n\t        newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\t\n\t    if (data) {\n\t      mergeData(newData, data);\n\t      bitmask = newData[1];\n\t      arity = newData[9];\n\t    }\n\t    newData[9] = arity == null\n\t      ? (isBindKey ? 0 : func.length)\n\t      : (nativeMax(arity - length, 0) || 0);\n\t\n\t    if (bitmask == BIND_FLAG) {\n\t      var result = createBindWrapper(newData[0], newData[2]);\n\t    } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\n\t      result = createPartialWrapper.apply(undefined, newData);\n\t    } else {\n\t      result = createHybridWrapper.apply(undefined, newData);\n\t    }\n\t    var setter = data ? baseSetData : setData;\n\t    return setter(result, newData);\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `baseIsEqualDeep` for arrays with support for\n\t   * partial deep comparisons.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to compare.\n\t   * @param {Array} other The other array to compare.\n\t   * @param {Function} equalFunc The function to determine equivalents of values.\n\t   * @param {Function} [customizer] The function to customize comparing arrays.\n\t   * @param {boolean} [isLoose] Specify performing partial comparisons.\n\t   * @param {Array} [stackA] Tracks traversed `value` objects.\n\t   * @param {Array} [stackB] Tracks traversed `other` objects.\n\t   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n\t   */\n\t  function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n\t    var index = -1,\n\t        arrLength = array.length,\n\t        othLength = other.length;\n\t\n\t    if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n\t      return false;\n\t    }\n\t    // Ignore non-index properties.\n\t    while (++index < arrLength) {\n\t      var arrValue = array[index],\n\t          othValue = other[index],\n\t          result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;\n\t\n\t      if (result !== undefined) {\n\t        if (result) {\n\t          continue;\n\t        }\n\t        return false;\n\t      }\n\t      // Recursively compare arrays (susceptible to call stack limits).\n\t      if (isLoose) {\n\t        if (!arraySome(other, function(othValue) {\n\t              return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n\t            })) {\n\t          return false;\n\t        }\n\t      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `baseIsEqualDeep` for comparing objects of\n\t   * the same `toStringTag`.\n\t   *\n\t   * **Note:** This function only supports comparing values with tags of\n\t   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to compare.\n\t   * @param {Object} other The other object to compare.\n\t   * @param {string} tag The `toStringTag` of the objects to compare.\n\t   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t   */\n\t  function equalByTag(object, other, tag) {\n\t    switch (tag) {\n\t      case boolTag:\n\t      case dateTag:\n\t        // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n\t        // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n\t        return +object == +other;\n\t\n\t      case errorTag:\n\t        return object.name == other.name && object.message == other.message;\n\t\n\t      case numberTag:\n\t        // Treat `NaN` vs. `NaN` as equal.\n\t        return (object != +object)\n\t          ? other != +other\n\t          : object == +other;\n\t\n\t      case regexpTag:\n\t      case stringTag:\n\t        // Coerce regexes to strings and treat strings primitives and string\n\t        // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n\t        return object == (other + \'\');\n\t    }\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `baseIsEqualDeep` for objects with support for\n\t   * partial deep comparisons.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to compare.\n\t   * @param {Object} other The other object to compare.\n\t   * @param {Function} equalFunc The function to determine equivalents of values.\n\t   * @param {Function} [customizer] The function to customize comparing values.\n\t   * @param {boolean} [isLoose] Specify performing partial comparisons.\n\t   * @param {Array} [stackA] Tracks traversed `value` objects.\n\t   * @param {Array} [stackB] Tracks traversed `other` objects.\n\t   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t   */\n\t  function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n\t    var objProps = keys(object),\n\t        objLength = objProps.length,\n\t        othProps = keys(other),\n\t        othLength = othProps.length;\n\t\n\t    if (objLength != othLength && !isLoose) {\n\t      return false;\n\t    }\n\t    var index = objLength;\n\t    while (index--) {\n\t      var key = objProps[index];\n\t      if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n\t        return false;\n\t      }\n\t    }\n\t    var skipCtor = isLoose;\n\t    while (++index < objLength) {\n\t      key = objProps[index];\n\t      var objValue = object[key],\n\t          othValue = other[key],\n\t          result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;\n\t\n\t      // Recursively compare objects (susceptible to call stack limits).\n\t      if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {\n\t        return false;\n\t      }\n\t      skipCtor || (skipCtor = key == \'constructor\');\n\t    }\n\t    if (!skipCtor) {\n\t      var objCtor = object.constructor,\n\t          othCtor = other.constructor;\n\t\n\t      // Non `Object` object instances with different constructors are not equal.\n\t      if (objCtor != othCtor &&\n\t          (\'constructor\' in object && \'constructor\' in other) &&\n\t          !(typeof objCtor == \'function\' && objCtor instanceof objCtor &&\n\t            typeof othCtor == \'function\' && othCtor instanceof othCtor)) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  /**\n\t   * Gets the appropriate "callback" function. If the `_.callback` method is\n\t   * customized this function returns the custom method, otherwise it returns\n\t   * the `baseCallback` function. If arguments are provided the chosen function\n\t   * is invoked with them and its result is returned.\n\t   *\n\t   * @private\n\t   * @returns {Function} Returns the chosen function or its result.\n\t   */\n\t  function getCallback(func, thisArg, argCount) {\n\t    var result = lodash.callback || callback;\n\t    result = result === callback ? baseCallback : result;\n\t    return argCount ? result(func, thisArg, argCount) : result;\n\t  }\n\t\n\t  /**\n\t   * Gets metadata for `func`.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to query.\n\t   * @returns {*} Returns the metadata for `func`.\n\t   */\n\t  var getData = !metaMap ? noop : function(func) {\n\t    return metaMap.get(func);\n\t  };\n\t\n\t  /**\n\t   * Gets the name of `func`.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to query.\n\t   * @returns {string} Returns the function name.\n\t   */\n\t  function getFuncName(func) {\n\t    var result = (func.name + \'\'),\n\t        array = realNames[result],\n\t        length = array ? array.length : 0;\n\t\n\t    while (length--) {\n\t      var data = array[length],\n\t          otherFunc = data.func;\n\t      if (otherFunc == null || otherFunc == func) {\n\t        return data.name;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Gets the appropriate "indexOf" function. If the `_.indexOf` method is\n\t   * customized this function returns the custom method, otherwise it returns\n\t   * the `baseIndexOf` function. If arguments are provided the chosen function\n\t   * is invoked with them and its result is returned.\n\t   *\n\t   * @private\n\t   * @returns {Function|number} Returns the chosen function or its result.\n\t   */\n\t  function getIndexOf(collection, target, fromIndex) {\n\t    var result = lodash.indexOf || indexOf;\n\t    result = result === indexOf ? baseIndexOf : result;\n\t    return collection ? result(collection, target, fromIndex) : result;\n\t  }\n\t\n\t  /**\n\t   * Gets the "length" property value of `object`.\n\t   *\n\t   * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n\t   * that affects Safari on at least iOS 8.1-8.3 ARM64.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @returns {*} Returns the "length" value.\n\t   */\n\t  var getLength = baseProperty(\'length\');\n\t\n\t  /**\n\t   * Gets the propery names, values, and compare flags of `object`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @returns {Array} Returns the match data of `object`.\n\t   */\n\t  function getMatchData(object) {\n\t    var result = pairs(object),\n\t        length = result.length;\n\t\n\t    while (length--) {\n\t      result[length][2] = isStrictComparable(result[length][1]);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Gets the native function at `key` of `object`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @param {string} key The key of the method to get.\n\t   * @returns {*} Returns the function if it\'s native, else `undefined`.\n\t   */\n\t  function getNative(object, key) {\n\t    var value = object == null ? undefined : object[key];\n\t    return isNative(value) ? value : undefined;\n\t  }\n\t\n\t  /**\n\t   * Initializes an array clone.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to clone.\n\t   * @returns {Array} Returns the initialized clone.\n\t   */\n\t  function initCloneArray(array) {\n\t    var length = array.length,\n\t        result = new array.constructor(length);\n\t\n\t    // Add array properties assigned by `RegExp#exec`.\n\t    if (length && typeof array[0] == \'string\' && hasOwnProperty.call(array, \'index\')) {\n\t      result.index = array.index;\n\t      result.input = array.input;\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Initializes an object clone.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to clone.\n\t   * @returns {Object} Returns the initialized clone.\n\t   */\n\t  function initCloneObject(object) {\n\t    var Ctor = object.constructor;\n\t    if (!(typeof Ctor == \'function\' && Ctor instanceof Ctor)) {\n\t      Ctor = Object;\n\t    }\n\t    return new Ctor;\n\t  }\n\t\n\t  /**\n\t   * Initializes an object clone based on its `toStringTag`.\n\t   *\n\t   * **Note:** This function only supports cloning values with tags of\n\t   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to clone.\n\t   * @param {string} tag The `toStringTag` of the object to clone.\n\t   * @param {boolean} [isDeep] Specify a deep clone.\n\t   * @returns {Object} Returns the initialized clone.\n\t   */\n\t  function initCloneByTag(object, tag, isDeep) {\n\t    var Ctor = object.constructor;\n\t    switch (tag) {\n\t      case arrayBufferTag:\n\t        return bufferClone(object);\n\t\n\t      case boolTag:\n\t      case dateTag:\n\t        return new Ctor(+object);\n\t\n\t      case float32Tag: case float64Tag:\n\t      case int8Tag: case int16Tag: case int32Tag:\n\t      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n\t        var buffer = object.buffer;\n\t        return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\t\n\t      case numberTag:\n\t      case stringTag:\n\t        return new Ctor(object);\n\t\n\t      case regexpTag:\n\t        var result = new Ctor(object.source, reFlags.exec(object));\n\t        result.lastIndex = object.lastIndex;\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is array-like.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n\t   */\n\t  function isArrayLike(value) {\n\t    return value != null && isLength(getLength(value));\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is a valid array-like index.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t   */\n\t  function isIndex(value, length) {\n\t    value = (typeof value == \'number\' || reIsUint.test(value)) ? +value : -1;\n\t    length = length == null ? MAX_SAFE_INTEGER : length;\n\t    return value > -1 && value % 1 == 0 && value < length;\n\t  }\n\t\n\t  /**\n\t   * Checks if the provided arguments are from an iteratee call.\n\t   *\n\t   * @private\n\t   * @param {*} value The potential iteratee value argument.\n\t   * @param {*} index The potential iteratee index or key argument.\n\t   * @param {*} object The potential iteratee object argument.\n\t   * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n\t   */\n\t  function isIterateeCall(value, index, object) {\n\t    if (!isObject(object)) {\n\t      return false;\n\t    }\n\t    var type = typeof index;\n\t    if (type == \'number\'\n\t        ? (isArrayLike(object) && isIndex(index, object.length))\n\t        : (type == \'string\' && index in object)) {\n\t      var other = object[index];\n\t      return value === value ? (value === other) : (other !== other);\n\t    }\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is a property name and not a property path.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @param {Object} [object] The object to query keys on.\n\t   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n\t   */\n\t  function isKey(value, object) {\n\t    var type = typeof value;\n\t    if ((type == \'string\' && reIsPlainProp.test(value)) || type == \'number\') {\n\t      return true;\n\t    }\n\t    if (isArray(value)) {\n\t      return false;\n\t    }\n\t    var result = !reIsDeepProp.test(value);\n\t    return result || (object != null && value in toObject(object));\n\t  }\n\t\n\t  /**\n\t   * Checks if `func` has a lazy counterpart.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to check.\n\t   * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\n\t   */\n\t  function isLaziable(func) {\n\t    var funcName = getFuncName(func),\n\t        other = lodash[funcName];\n\t\n\t    if (typeof other != \'function\' || !(funcName in LazyWrapper.prototype)) {\n\t      return false;\n\t    }\n\t    if (func === other) {\n\t      return true;\n\t    }\n\t    var data = getData(other);\n\t    return !!data && func === data[0];\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is a valid array-like length.\n\t   *\n\t   * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t   */\n\t  function isLength(value) {\n\t    return typeof value == \'number\' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` if suitable for strict\n\t   *  equality comparisons, else `false`.\n\t   */\n\t  function isStrictComparable(value) {\n\t    return value === value && !isObject(value);\n\t  }\n\t\n\t  /**\n\t   * Merges the function metadata of `source` into `data`.\n\t   *\n\t   * Merging metadata reduces the number of wrappers required to invoke a function.\n\t   * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n\t   * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n\t   * augment function arguments, making the order in which they are executed important,\n\t   * preventing the merging of metadata. However, we make an exception for a safe\n\t   * common case where curried functions have `_.ary` and or `_.rearg` applied.\n\t   *\n\t   * @private\n\t   * @param {Array} data The destination metadata.\n\t   * @param {Array} source The source metadata.\n\t   * @returns {Array} Returns `data`.\n\t   */\n\t  function mergeData(data, source) {\n\t    var bitmask = data[1],\n\t        srcBitmask = source[1],\n\t        newBitmask = bitmask | srcBitmask,\n\t        isCommon = newBitmask < ARY_FLAG;\n\t\n\t    var isCombo =\n\t      (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||\n\t      (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||\n\t      (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);\n\t\n\t    // Exit early if metadata can\'t be merged.\n\t    if (!(isCommon || isCombo)) {\n\t      return data;\n\t    }\n\t    // Use source `thisArg` if available.\n\t    if (srcBitmask & BIND_FLAG) {\n\t      data[2] = source[2];\n\t      // Set when currying a bound function.\n\t      newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n\t    }\n\t    // Compose partial arguments.\n\t    var value = source[3];\n\t    if (value) {\n\t      var partials = data[3];\n\t      data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\n\t      data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\n\t    }\n\t    // Compose partial right arguments.\n\t    value = source[5];\n\t    if (value) {\n\t      partials = data[5];\n\t      data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\n\t      data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\n\t    }\n\t    // Use source `argPos` if available.\n\t    value = source[7];\n\t    if (value) {\n\t      data[7] = arrayCopy(value);\n\t    }\n\t    // Use source `ary` if it\'s smaller.\n\t    if (srcBitmask & ARY_FLAG) {\n\t      data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n\t    }\n\t    // Use source `arity` if one is not provided.\n\t    if (data[9] == null) {\n\t      data[9] = source[9];\n\t    }\n\t    // Use source `func` and merge bitmasks.\n\t    data[0] = source[0];\n\t    data[1] = newBitmask;\n\t\n\t    return data;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.defaultsDeep` to customize its `_.merge` use.\n\t   *\n\t   * @private\n\t   * @param {*} objectValue The destination object property value.\n\t   * @param {*} sourceValue The source object property value.\n\t   * @returns {*} Returns the value to assign to the destination object.\n\t   */\n\t  function mergeDefaults(objectValue, sourceValue) {\n\t    return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.pick` which picks `object` properties specified\n\t   * by `props`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The source object.\n\t   * @param {string[]} props The property names to pick.\n\t   * @returns {Object} Returns the new object.\n\t   */\n\t  function pickByArray(object, props) {\n\t    object = toObject(object);\n\t\n\t    var index = -1,\n\t        length = props.length,\n\t        result = {};\n\t\n\t    while (++index < length) {\n\t      var key = props[index];\n\t      if (key in object) {\n\t        result[key] = object[key];\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.pick` which picks `object` properties `predicate`\n\t   * returns truthy for.\n\t   *\n\t   * @private\n\t   * @param {Object} object The source object.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {Object} Returns the new object.\n\t   */\n\t  function pickByCallback(object, predicate) {\n\t    var result = {};\n\t    baseForIn(object, function(value, key, object) {\n\t      if (predicate(value, key, object)) {\n\t        result[key] = value;\n\t      }\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Reorder `array` according to the specified indexes where the element at\n\t   * the first index is assigned as the first element, the element at\n\t   * the second index is assigned as the second element, and so on.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to reorder.\n\t   * @param {Array} indexes The arranged array indexes.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function reorder(array, indexes) {\n\t    var arrLength = array.length,\n\t        length = nativeMin(indexes.length, arrLength),\n\t        oldArray = arrayCopy(array);\n\t\n\t    while (length--) {\n\t      var index = indexes[length];\n\t      array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * Sets metadata for `func`.\n\t   *\n\t   * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n\t   * period of time, it will trip its breaker and transition to an identity function\n\t   * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n\t   * for more details.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to associate metadata with.\n\t   * @param {*} data The metadata.\n\t   * @returns {Function} Returns `func`.\n\t   */\n\t  var setData = (function() {\n\t    var count = 0,\n\t        lastCalled = 0;\n\t\n\t    return function(key, value) {\n\t      var stamp = now(),\n\t          remaining = HOT_SPAN - (stamp - lastCalled);\n\t\n\t      lastCalled = stamp;\n\t      if (remaining > 0) {\n\t        if (++count >= HOT_COUNT) {\n\t          return key;\n\t        }\n\t      } else {\n\t        count = 0;\n\t      }\n\t      return baseSetData(key, value);\n\t    };\n\t  }());\n\t\n\t  /**\n\t   * A fallback implementation of `Object.keys` which creates an array of the\n\t   * own enumerable property names of `object`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @returns {Array} Returns the array of property names.\n\t   */\n\t  function shimKeys(object) {\n\t    var props = keysIn(object),\n\t        propsLength = props.length,\n\t        length = propsLength && object.length;\n\t\n\t    var allowIndexes = !!length && isLength(length) &&\n\t      (isArray(object) || isArguments(object));\n\t\n\t    var index = -1,\n\t        result = [];\n\t\n\t    while (++index < propsLength) {\n\t      var key = props[index];\n\t      if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n\t        result.push(key);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Converts `value` to an array-like object if it\'s not one.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to process.\n\t   * @returns {Array|Object} Returns the array-like object.\n\t   */\n\t  function toIterable(value) {\n\t    if (value == null) {\n\t      return [];\n\t    }\n\t    if (!isArrayLike(value)) {\n\t      return values(value);\n\t    }\n\t    return isObject(value) ? value : Object(value);\n\t  }\n\t\n\t  /**\n\t   * Converts `value` to an object if it\'s not one.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to process.\n\t   * @returns {Object} Returns the object.\n\t   */\n\t  function toObject(value) {\n\t    return isObject(value) ? value : Object(value);\n\t  }\n\t\n\t  /**\n\t   * Converts `value` to property path array if it\'s not one.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to process.\n\t   * @returns {Array} Returns the property path array.\n\t   */\n\t  function toPath(value) {\n\t    if (isArray(value)) {\n\t      return value;\n\t    }\n\t    var result = [];\n\t    baseToString(value).replace(rePropName, function(match, number, quote, string) {\n\t      result.push(quote ? string.replace(reEscapeChar, \'$1\') : (number || match));\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Creates an array with all falsey values removed. The values `false`, `null`,\n\t   * `0`, `""`, `undefined`, and `NaN` are falsey.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Array\n\t   * @param {Array} array The array to compact.\n\t   * @returns {Array} Returns the new array of filtered values.\n\t   * @example\n\t   *\n\t   * _.compact([0, 1, false, 2, \'\', 3]);\n\t   * // => [1, 2, 3]\n\t   */\n\t  function compact(array) {\n\t    var index = -1,\n\t        length = array ? array.length : 0,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      var value = array[index];\n\t      if (value) {\n\t        result[++resIndex] = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Creates an array of unique `array` values not included in the other\n\t   * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t   * for equality comparisons.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Array\n\t   * @param {Array} array The array to inspect.\n\t   * @param {...Array} [values] The arrays of values to exclude.\n\t   * @returns {Array} Returns the new array of filtered values.\n\t   * @example\n\t   *\n\t   * _.difference([1, 2, 3], [4, 2]);\n\t   * // => [1, 3]\n\t   */\n\t  var difference = restParam(function(array, values) {\n\t    return (isObjectLike(array) && isArrayLike(array))\n\t      ? baseDifference(array, baseFlatten(values, false, true))\n\t      : [];\n\t  });\n\t\n\t  /**\n\t   * Flattens a nested array. If `isDeep` is `true` the array is recursively\n\t   * flattened, otherwise it\'s only flattened a single level.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Array\n\t   * @param {Array} array The array to flatten.\n\t   * @param {boolean} [isDeep] Specify a deep flatten.\n\t   * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t   * @returns {Array} Returns the new flattened array.\n\t   * @example\n\t   *\n\t   * _.flatten([1, [2, 3, [4]]]);\n\t   * // => [1, 2, 3, [4]]\n\t   *\n\t   * // using `isDeep`\n\t   * _.flatten([1, [2, 3, [4]]], true);\n\t   * // => [1, 2, 3, 4]\n\t   */\n\t  function flatten(array, isDeep, guard) {\n\t    var length = array ? array.length : 0;\n\t    if (guard && isIterateeCall(array, isDeep, guard)) {\n\t      isDeep = false;\n\t    }\n\t    return length ? baseFlatten(array, isDeep) : [];\n\t  }\n\t\n\t  /**\n\t   * Recursively flattens a nested array.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Array\n\t   * @param {Array} array The array to recursively flatten.\n\t   * @returns {Array} Returns the new flattened array.\n\t   * @example\n\t   *\n\t   * _.flattenDeep([1, [2, 3, [4]]]);\n\t   * // => [1, 2, 3, 4]\n\t   */\n\t  function flattenDeep(array) {\n\t    var length = array ? array.length : 0;\n\t    return length ? baseFlatten(array, true) : [];\n\t  }\n\t\n\t  /**\n\t   * Gets the index at which the first occurrence of `value` is found in `array`\n\t   * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t   * for equality comparisons. If `fromIndex` is negative, it\'s used as the offset\n\t   * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`\n\t   * performs a faster binary search.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Array\n\t   * @param {Array} array The array to search.\n\t   * @param {*} value The value to search for.\n\t   * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n\t   *  to perform a binary search on a sorted array.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   * @example\n\t   *\n\t   * _.indexOf([1, 2, 1, 2], 2);\n\t   * // => 1\n\t   *\n\t   * // using `fromIndex`\n\t   * _.indexOf([1, 2, 1, 2], 2, 2);\n\t   * // => 3\n\t   *\n\t   * // performing a binary search\n\t   * _.indexOf([1, 1, 2, 2], 2, true);\n\t   * // => 2\n\t   */\n\t  function indexOf(array, value, fromIndex) {\n\t    var length = array ? array.length : 0;\n\t    if (!length) {\n\t      return -1;\n\t    }\n\t    if (typeof fromIndex == \'number\') {\n\t      fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;\n\t    } else if (fromIndex) {\n\t      var index = binaryIndex(array, value);\n\t      if (index < length &&\n\t          (value === value ? (value === array[index]) : (array[index] !== array[index]))) {\n\t        return index;\n\t      }\n\t      return -1;\n\t    }\n\t    return baseIndexOf(array, value, fromIndex || 0);\n\t  }\n\t\n\t  /**\n\t   * Gets the last element of `array`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Array\n\t   * @param {Array} array The array to query.\n\t   * @returns {*} Returns the last element of `array`.\n\t   * @example\n\t   *\n\t   * _.last([1, 2, 3]);\n\t   * // => 3\n\t   */\n\t  function last(array) {\n\t    var length = array ? array.length : 0;\n\t    return length ? array[length - 1] : undefined;\n\t  }\n\t\n\t  /**\n\t   * Removes all elements from `array` that `predicate` returns truthy for\n\t   * and returns an array of the removed elements. The predicate is bound to\n\t   * `thisArg` and invoked with three arguments: (value, index, array).\n\t   *\n\t   * If a property name is provided for `predicate` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `predicate` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * **Note:** Unlike `_.filter`, this method mutates `array`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Array\n\t   * @param {Array} array The array to modify.\n\t   * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `predicate`.\n\t   * @returns {Array} Returns the new array of removed elements.\n\t   * @example\n\t   *\n\t   * var array = [1, 2, 3, 4];\n\t   * var evens = _.remove(array, function(n) {\n\t   *   return n % 2 == 0;\n\t   * });\n\t   *\n\t   * console.log(array);\n\t   * // => [1, 3]\n\t   *\n\t   * console.log(evens);\n\t   * // => [2, 4]\n\t   */\n\t  function remove(array, predicate, thisArg) {\n\t    var result = [];\n\t    if (!(array && array.length)) {\n\t      return result;\n\t    }\n\t    var index = -1,\n\t        indexes = [],\n\t        length = array.length;\n\t\n\t    predicate = getCallback(predicate, thisArg, 3);\n\t    while (++index < length) {\n\t      var value = array[index];\n\t      if (predicate(value, index, array)) {\n\t        result.push(value);\n\t        indexes.push(index);\n\t      }\n\t    }\n\t    basePullAt(array, indexes);\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Creates an array of unique values, in order, from all of the provided arrays\n\t   * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t   * for equality comparisons.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Array\n\t   * @param {...Array} [arrays] The arrays to inspect.\n\t   * @returns {Array} Returns the new array of combined values.\n\t   * @example\n\t   *\n\t   * _.union([1, 2], [4, 2], [2, 1]);\n\t   * // => [1, 2, 4]\n\t   */\n\t  var union = restParam(function(arrays) {\n\t    return baseUniq(baseFlatten(arrays, false, true));\n\t  });\n\t\n\t  /**\n\t   * Creates a duplicate-free version of an array, using\n\t   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t   * for equality comparisons, in which only the first occurence of each element\n\t   * is kept. Providing `true` for `isSorted` performs a faster search algorithm\n\t   * for sorted arrays. If an iteratee function is provided it\'s invoked for\n\t   * each element in the array to generate the criterion by which uniqueness\n\t   * is computed. The `iteratee` is bound to `thisArg` and invoked with three\n\t   * arguments: (value, index, array).\n\t   *\n\t   * If a property name is provided for `iteratee` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `iteratee` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias unique\n\t   * @category Array\n\t   * @param {Array} array The array to inspect.\n\t   * @param {boolean} [isSorted] Specify the array is sorted.\n\t   * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {Array} Returns the new duplicate-value-free array.\n\t   * @example\n\t   *\n\t   * _.uniq([2, 1, 2]);\n\t   * // => [2, 1]\n\t   *\n\t   * // using `isSorted`\n\t   * _.uniq([1, 1, 2], true);\n\t   * // => [1, 2]\n\t   *\n\t   * // using an iteratee function\n\t   * _.uniq([1, 2.5, 1.5, 2], function(n) {\n\t   *   return this.floor(n);\n\t   * }, Math);\n\t   * // => [1, 2.5]\n\t   *\n\t   * // using the `_.property` callback shorthand\n\t   * _.uniq([{ \'x\': 1 }, { \'x\': 2 }, { \'x\': 1 }], \'x\');\n\t   * // => [{ \'x\': 1 }, { \'x\': 2 }]\n\t   */\n\t  function uniq(array, isSorted, iteratee, thisArg) {\n\t    var length = array ? array.length : 0;\n\t    if (!length) {\n\t      return [];\n\t    }\n\t    if (isSorted != null && typeof isSorted != \'boolean\') {\n\t      thisArg = iteratee;\n\t      iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;\n\t      isSorted = false;\n\t    }\n\t    var callback = getCallback();\n\t    if (!(iteratee == null && callback === baseCallback)) {\n\t      iteratee = callback(iteratee, thisArg, 3);\n\t    }\n\t    return (isSorted && getIndexOf() === baseIndexOf)\n\t      ? sortedUniq(array, iteratee)\n\t      : baseUniq(array, iteratee);\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Creates an object composed of keys generated from the results of running\n\t   * each element of `collection` through `iteratee`. The corresponding value\n\t   * of each key is the number of times the key was returned by `iteratee`.\n\t   * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n\t   * (value, index|key, collection).\n\t   *\n\t   * If a property name is provided for `iteratee` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `iteratee` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {Object} Returns the composed aggregate object.\n\t   * @example\n\t   *\n\t   * _.countBy([4.3, 6.1, 6.4], function(n) {\n\t   *   return Math.floor(n);\n\t   * });\n\t   * // => { \'4\': 1, \'6\': 2 }\n\t   *\n\t   * _.countBy([4.3, 6.1, 6.4], function(n) {\n\t   *   return this.floor(n);\n\t   * }, Math);\n\t   * // => { \'4\': 1, \'6\': 2 }\n\t   *\n\t   * _.countBy([\'one\', \'two\', \'three\'], \'length\');\n\t   * // => { \'3\': 2, \'5\': 1 }\n\t   */\n\t  var countBy = createAggregator(function(result, value, key) {\n\t    hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\n\t  });\n\t\n\t  /**\n\t   * Checks if `predicate` returns truthy for **all** elements of `collection`.\n\t   * The predicate is bound to `thisArg` and invoked with three arguments:\n\t   * (value, index|key, collection).\n\t   *\n\t   * If a property name is provided for `predicate` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `predicate` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias all\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `predicate`.\n\t   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t   *  else `false`.\n\t   * @example\n\t   *\n\t   * _.every([true, 1, null, \'yes\'], Boolean);\n\t   * // => false\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\', \'active\': false },\n\t   *   { \'user\': \'fred\',   \'active\': false }\n\t   * ];\n\t   *\n\t   * // using the `_.matches` callback shorthand\n\t   * _.every(users, { \'user\': \'barney\', \'active\': false });\n\t   * // => false\n\t   *\n\t   * // using the `_.matchesProperty` callback shorthand\n\t   * _.every(users, \'active\', false);\n\t   * // => true\n\t   *\n\t   * // using the `_.property` callback shorthand\n\t   * _.every(users, \'active\');\n\t   * // => false\n\t   */\n\t  function every(collection, predicate, thisArg) {\n\t    var func = isArray(collection) ? arrayEvery : baseEvery;\n\t    if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n\t      predicate = undefined;\n\t    }\n\t    if (typeof predicate != \'function\' || thisArg !== undefined) {\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t    }\n\t    return func(collection, predicate);\n\t  }\n\t\n\t  /**\n\t   * Iterates over elements of `collection`, returning an array of all elements\n\t   * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n\t   * invoked with three arguments: (value, index|key, collection).\n\t   *\n\t   * If a property name is provided for `predicate` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `predicate` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias select\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `predicate`.\n\t   * @returns {Array} Returns the new filtered array.\n\t   * @example\n\t   *\n\t   * _.filter([4, 5, 6], function(n) {\n\t   *   return n % 2 == 0;\n\t   * });\n\t   * // => [4, 6]\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\', \'age\': 36, \'active\': true },\n\t   *   { \'user\': \'fred\',   \'age\': 40, \'active\': false }\n\t   * ];\n\t   *\n\t   * // using the `_.matches` callback shorthand\n\t   * _.pluck(_.filter(users, { \'age\': 36, \'active\': true }), \'user\');\n\t   * // => [\'barney\']\n\t   *\n\t   * // using the `_.matchesProperty` callback shorthand\n\t   * _.pluck(_.filter(users, \'active\', false), \'user\');\n\t   * // => [\'fred\']\n\t   *\n\t   * // using the `_.property` callback shorthand\n\t   * _.pluck(_.filter(users, \'active\'), \'user\');\n\t   * // => [\'barney\']\n\t   */\n\t  function filter(collection, predicate, thisArg) {\n\t    var func = isArray(collection) ? arrayFilter : baseFilter;\n\t    predicate = getCallback(predicate, thisArg, 3);\n\t    return func(collection, predicate);\n\t  }\n\t\n\t  /**\n\t   * Iterates over elements of `collection`, returning the first element\n\t   * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n\t   * invoked with three arguments: (value, index|key, collection).\n\t   *\n\t   * If a property name is provided for `predicate` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `predicate` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias detect\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to search.\n\t   * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `predicate`.\n\t   * @returns {*} Returns the matched element, else `undefined`.\n\t   * @example\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\',  \'age\': 36, \'active\': true },\n\t   *   { \'user\': \'fred\',    \'age\': 40, \'active\': false },\n\t   *   { \'user\': \'pebbles\', \'age\': 1,  \'active\': true }\n\t   * ];\n\t   *\n\t   * _.result(_.find(users, function(chr) {\n\t   *   return chr.age < 40;\n\t   * }), \'user\');\n\t   * // => \'barney\'\n\t   *\n\t   * // using the `_.matches` callback shorthand\n\t   * _.result(_.find(users, { \'age\': 1, \'active\': true }), \'user\');\n\t   * // => \'pebbles\'\n\t   *\n\t   * // using the `_.matchesProperty` callback shorthand\n\t   * _.result(_.find(users, \'active\', false), \'user\');\n\t   * // => \'fred\'\n\t   *\n\t   * // using the `_.property` callback shorthand\n\t   * _.result(_.find(users, \'active\'), \'user\');\n\t   * // => \'barney\'\n\t   */\n\t  var find = createFind(baseEach);\n\t\n\t  /**\n\t   * Iterates over elements of `collection` invoking `iteratee` for each element.\n\t   * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n\t   * (value, index|key, collection). Iteratee functions may exit iteration early\n\t   * by explicitly returning `false`.\n\t   *\n\t   * **Note:** As with other "Collections" methods, objects with a "length" property\n\t   * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n\t   * may be used for object iteration.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias each\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {Array|Object|string} Returns `collection`.\n\t   * @example\n\t   *\n\t   * _([1, 2]).forEach(function(n) {\n\t   *   console.log(n);\n\t   * }).value();\n\t   * // => logs each value from left to right and returns the array\n\t   *\n\t   * _.forEach({ \'a\': 1, \'b\': 2 }, function(n, key) {\n\t   *   console.log(n, key);\n\t   * });\n\t   * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n\t   */\n\t  var forEach = createForEach(arrayEach, baseEach);\n\t\n\t  /**\n\t   * Checks if `target` is in `collection` using\n\t   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t   * for equality comparisons. If `fromIndex` is negative, it\'s used as the offset\n\t   * from the end of `collection`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias contains, include\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to search.\n\t   * @param {*} target The value to search for.\n\t   * @param {number} [fromIndex=0] The index to search from.\n\t   * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n\t   * @returns {boolean} Returns `true` if a matching element is found, else `false`.\n\t   * @example\n\t   *\n\t   * _.includes([1, 2, 3], 1);\n\t   * // => true\n\t   *\n\t   * _.includes([1, 2, 3], 1, 2);\n\t   * // => false\n\t   *\n\t   * _.includes({ \'user\': \'fred\', \'age\': 40 }, \'fred\');\n\t   * // => true\n\t   *\n\t   * _.includes(\'pebbles\', \'eb\');\n\t   * // => true\n\t   */\n\t  function includes(collection, target, fromIndex, guard) {\n\t    var length = collection ? getLength(collection) : 0;\n\t    if (!isLength(length)) {\n\t      collection = values(collection);\n\t      length = collection.length;\n\t    }\n\t    if (typeof fromIndex != \'number\' || (guard && isIterateeCall(target, fromIndex, guard))) {\n\t      fromIndex = 0;\n\t    } else {\n\t      fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n\t    }\n\t    return (typeof collection == \'string\' || !isArray(collection) && isString(collection))\n\t      ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)\n\t      : (!!length && getIndexOf(collection, target, fromIndex) > -1);\n\t  }\n\t\n\t  /**\n\t   * Creates an array of values by running each element in `collection` through\n\t   * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\n\t   * arguments: (value, index|key, collection).\n\t   *\n\t   * If a property name is provided for `iteratee` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `iteratee` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * Many lodash methods are guarded to work as iteratees for methods like\n\t   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n\t   *\n\t   * The guarded methods are:\n\t   * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,\n\t   * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,\n\t   * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,\n\t   * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,\n\t   * `sum`, `uniq`, and `words`\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias collect\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {Array} Returns the new mapped array.\n\t   * @example\n\t   *\n\t   * function timesThree(n) {\n\t   *   return n * 3;\n\t   * }\n\t   *\n\t   * _.map([1, 2], timesThree);\n\t   * // => [3, 6]\n\t   *\n\t   * _.map({ \'a\': 1, \'b\': 2 }, timesThree);\n\t   * // => [3, 6] (iteration order is not guaranteed)\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\' },\n\t   *   { \'user\': \'fred\' }\n\t   * ];\n\t   *\n\t   * // using the `_.property` callback shorthand\n\t   * _.map(users, \'user\');\n\t   * // => [\'barney\', \'fred\']\n\t   */\n\t  function map(collection, iteratee, thisArg) {\n\t    var func = isArray(collection) ? arrayMap : baseMap;\n\t    iteratee = getCallback(iteratee, thisArg, 3);\n\t    return func(collection, iteratee);\n\t  }\n\t\n\t  /**\n\t   * Gets the property value of `path` from all elements in `collection`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Array|string} path The path of the property to pluck.\n\t   * @returns {Array} Returns the property values.\n\t   * @example\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\', \'age\': 36 },\n\t   *   { \'user\': \'fred\',   \'age\': 40 }\n\t   * ];\n\t   *\n\t   * _.pluck(users, \'user\');\n\t   * // => [\'barney\', \'fred\']\n\t   *\n\t   * var userIndex = _.indexBy(users, \'user\');\n\t   * _.pluck(userIndex, \'age\');\n\t   * // => [36, 40] (iteration order is not guaranteed)\n\t   */\n\t  function pluck(collection, path) {\n\t    return map(collection, property(path));\n\t  }\n\t\n\t  /**\n\t   * Reduces `collection` to a value which is the accumulated result of running\n\t   * each element in `collection` through `iteratee`, where each successive\n\t   * invocation is supplied the return value of the previous. If `accumulator`\n\t   * is not provided the first element of `collection` is used as the initial\n\t   * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:\n\t   * (accumulator, value, index|key, collection).\n\t   *\n\t   * Many lodash methods are guarded to work as iteratees for methods like\n\t   * `_.reduce`, `_.reduceRight`, and `_.transform`.\n\t   *\n\t   * The guarded methods are:\n\t   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,\n\t   * and `sortByOrder`\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias foldl, inject\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t   * @param {*} [accumulator] The initial value.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {*} Returns the accumulated value.\n\t   * @example\n\t   *\n\t   * _.reduce([1, 2], function(total, n) {\n\t   *   return total + n;\n\t   * });\n\t   * // => 3\n\t   *\n\t   * _.reduce({ \'a\': 1, \'b\': 2 }, function(result, n, key) {\n\t   *   result[key] = n * 3;\n\t   *   return result;\n\t   * }, {});\n\t   * // => { \'a\': 3, \'b\': 6 } (iteration order is not guaranteed)\n\t   */\n\t  var reduce = createReduce(arrayReduce, baseEach);\n\t\n\t  /**\n\t   * Gets the size of `collection` by returning its length for array-like\n\t   * values or the number of own enumerable properties for objects.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to inspect.\n\t   * @returns {number} Returns the size of `collection`.\n\t   * @example\n\t   *\n\t   * _.size([1, 2, 3]);\n\t   * // => 3\n\t   *\n\t   * _.size({ \'a\': 1, \'b\': 2 });\n\t   * // => 2\n\t   *\n\t   * _.size(\'pebbles\');\n\t   * // => 7\n\t   */\n\t  function size(collection) {\n\t    var length = collection ? getLength(collection) : 0;\n\t    return isLength(length) ? length : keys(collection).length;\n\t  }\n\t\n\t  /**\n\t   * Checks if `predicate` returns truthy for **any** element of `collection`.\n\t   * The function returns as soon as it finds a passing value and does not iterate\n\t   * over the entire collection. The predicate is bound to `thisArg` and invoked\n\t   * with three arguments: (value, index|key, collection).\n\t   *\n\t   * If a property name is provided for `predicate` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `predicate` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias any\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `predicate`.\n\t   * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t   *  else `false`.\n\t   * @example\n\t   *\n\t   * _.some([null, 0, \'yes\', false], Boolean);\n\t   * // => true\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\', \'active\': true },\n\t   *   { \'user\': \'fred\',   \'active\': false }\n\t   * ];\n\t   *\n\t   * // using the `_.matches` callback shorthand\n\t   * _.some(users, { \'user\': \'barney\', \'active\': false });\n\t   * // => false\n\t   *\n\t   * // using the `_.matchesProperty` callback shorthand\n\t   * _.some(users, \'active\', false);\n\t   * // => true\n\t   *\n\t   * // using the `_.property` callback shorthand\n\t   * _.some(users, \'active\');\n\t   * // => true\n\t   */\n\t  function some(collection, predicate, thisArg) {\n\t    var func = isArray(collection) ? arraySome : baseSome;\n\t    if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n\t      predicate = undefined;\n\t    }\n\t    if (typeof predicate != \'function\' || thisArg !== undefined) {\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t    }\n\t    return func(collection, predicate);\n\t  }\n\t\n\t  /**\n\t   * Creates an array of elements, sorted in ascending order by the results of\n\t   * running each element in a collection through `iteratee`. This method performs\n\t   * a stable sort, that is, it preserves the original sort order of equal elements.\n\t   * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n\t   * (value, index|key, collection).\n\t   *\n\t   * If a property name is provided for `iteratee` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `iteratee` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Collection\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {Array} Returns the new sorted array.\n\t   * @example\n\t   *\n\t   * _.sortBy([1, 2, 3], function(n) {\n\t   *   return Math.sin(n);\n\t   * });\n\t   * // => [3, 1, 2]\n\t   *\n\t   * _.sortBy([1, 2, 3], function(n) {\n\t   *   return this.sin(n);\n\t   * }, Math);\n\t   * // => [3, 1, 2]\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'fred\' },\n\t   *   { \'user\': \'pebbles\' },\n\t   *   { \'user\': \'barney\' }\n\t   * ];\n\t   *\n\t   * // using the `_.property` callback shorthand\n\t   * _.pluck(_.sortBy(users, \'user\'), \'user\');\n\t   * // => [\'barney\', \'fred\', \'pebbles\']\n\t   */\n\t  function sortBy(collection, iteratee, thisArg) {\n\t    if (collection == null) {\n\t      return [];\n\t    }\n\t    if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n\t      iteratee = undefined;\n\t    }\n\t    var index = -1;\n\t    iteratee = getCallback(iteratee, thisArg, 3);\n\t\n\t    var result = baseMap(collection, function(value, key, collection) {\n\t      return { \'criteria\': iteratee(value, key, collection), \'index\': ++index, \'value\': value };\n\t    });\n\t    return baseSortBy(result, compareAscending);\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Gets the number of milliseconds that have elapsed since the Unix epoch\n\t   * (1 January 1970 00:00:00 UTC).\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Date\n\t   * @example\n\t   *\n\t   * _.defer(function(stamp) {\n\t   *   console.log(_.now() - stamp);\n\t   * }, _.now());\n\t   * // => logs the number of milliseconds it took for the deferred function to be invoked\n\t   */\n\t  var now = nativeNow || function() {\n\t    return new Date().getTime();\n\t  };\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Creates a function that invokes `func` with the `this` binding of `thisArg`\n\t   * and prepends any additional `_.bind` arguments to those provided to the\n\t   * bound function.\n\t   *\n\t   * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n\t   * may be used as a placeholder for partially applied arguments.\n\t   *\n\t   * **Note:** Unlike native `Function#bind` this method does not set the "length"\n\t   * property of bound functions.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Function\n\t   * @param {Function} func The function to bind.\n\t   * @param {*} thisArg The `this` binding of `func`.\n\t   * @param {...*} [partials] The arguments to be partially applied.\n\t   * @returns {Function} Returns the new bound function.\n\t   * @example\n\t   *\n\t   * var greet = function(greeting, punctuation) {\n\t   *   return greeting + \' \' + this.user + punctuation;\n\t   * };\n\t   *\n\t   * var object = { \'user\': \'fred\' };\n\t   *\n\t   * var bound = _.bind(greet, object, \'hi\');\n\t   * bound(\'!\');\n\t   * // => \'hi fred!\'\n\t   *\n\t   * // using placeholders\n\t   * var bound = _.bind(greet, object, _, \'!\');\n\t   * bound(\'hi\');\n\t   * // => \'hi fred!\'\n\t   */\n\t  var bind = restParam(function(func, thisArg, partials) {\n\t    var bitmask = BIND_FLAG;\n\t    if (partials.length) {\n\t      var holders = replaceHolders(partials, bind.placeholder);\n\t      bitmask |= PARTIAL_FLAG;\n\t    }\n\t    return createWrapper(func, bitmask, thisArg, partials, holders);\n\t  });\n\t\n\t  /**\n\t   * Binds methods of an object to the object itself, overwriting the existing\n\t   * method. Method names may be specified as individual arguments or as arrays\n\t   * of method names. If no method names are provided all enumerable function\n\t   * properties, own and inherited, of `object` are bound.\n\t   *\n\t   * **Note:** This method does not set the "length" property of bound functions.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Function\n\t   * @param {Object} object The object to bind and assign the bound methods to.\n\t   * @param {...(string|string[])} [methodNames] The object method names to bind,\n\t   *  specified as individual method names or arrays of method names.\n\t   * @returns {Object} Returns `object`.\n\t   * @example\n\t   *\n\t   * var view = {\n\t   *   \'label\': \'docs\',\n\t   *   \'onClick\': function() {\n\t   *     console.log(\'clicked \' + this.label);\n\t   *   }\n\t   * };\n\t   *\n\t   * _.bindAll(view);\n\t   * jQuery(\'#docs\').on(\'click\', view.onClick);\n\t   * // => logs \'clicked docs\' when the element is clicked\n\t   */\n\t  var bindAll = restParam(function(object, methodNames) {\n\t    methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);\n\t\n\t    var index = -1,\n\t        length = methodNames.length;\n\t\n\t    while (++index < length) {\n\t      var key = methodNames[index];\n\t      object[key] = createWrapper(object[key], BIND_FLAG, object);\n\t    }\n\t    return object;\n\t  });\n\t\n\t  /**\n\t   * Creates a debounced function that delays invoking `func` until after `wait`\n\t   * milliseconds have elapsed since the last time the debounced function was\n\t   * invoked. The debounced function comes with a `cancel` method to cancel\n\t   * delayed invocations. Provide an options object to indicate that `func`\n\t   * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n\t   * Subsequent calls to the debounced function return the result of the last\n\t   * `func` invocation.\n\t   *\n\t   * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t   * on the trailing edge of the timeout only if the the debounced function is\n\t   * invoked more than once during the `wait` timeout.\n\t   *\n\t   * See [David Corbacho\'s article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t   * for details over the differences between `_.debounce` and `_.throttle`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Function\n\t   * @param {Function} func The function to debounce.\n\t   * @param {number} [wait=0] The number of milliseconds to delay.\n\t   * @param {Object} [options] The options object.\n\t   * @param {boolean} [options.leading=false] Specify invoking on the leading\n\t   *  edge of the timeout.\n\t   * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n\t   *  delayed before it\'s invoked.\n\t   * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t   *  edge of the timeout.\n\t   * @returns {Function} Returns the new debounced function.\n\t   * @example\n\t   *\n\t   * // avoid costly calculations while the window size is in flux\n\t   * jQuery(window).on(\'resize\', _.debounce(calculateLayout, 150));\n\t   *\n\t   * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n\t   * jQuery(\'#postbox\').on(\'click\', _.debounce(sendMail, 300, {\n\t   *   \'leading\': true,\n\t   *   \'trailing\': false\n\t   * }));\n\t   *\n\t   * // ensure `batchLog` is invoked once after 1 second of debounced calls\n\t   * var source = new EventSource(\'/stream\');\n\t   * jQuery(source).on(\'message\', _.debounce(batchLog, 250, {\n\t   *   \'maxWait\': 1000\n\t   * }));\n\t   *\n\t   * // cancel a debounced call\n\t   * var todoChanges = _.debounce(batchLog, 1000);\n\t   * Object.observe(models.todo, todoChanges);\n\t   *\n\t   * Object.observe(models, function(changes) {\n\t   *   if (_.find(changes, { \'user\': \'todo\', \'type\': \'delete\'})) {\n\t   *     todoChanges.cancel();\n\t   *   }\n\t   * }, [\'delete\']);\n\t   *\n\t   * // ...at some point `models.todo` is changed\n\t   * models.todo.completed = true;\n\t   *\n\t   * // ...before 1 second has passed `models.todo` is deleted\n\t   * // which cancels the debounced `todoChanges` call\n\t   * delete models.todo;\n\t   */\n\t  function debounce(func, wait, options) {\n\t    var args,\n\t        maxTimeoutId,\n\t        result,\n\t        stamp,\n\t        thisArg,\n\t        timeoutId,\n\t        trailingCall,\n\t        lastCalled = 0,\n\t        maxWait = false,\n\t        trailing = true;\n\t\n\t    if (typeof func != \'function\') {\n\t      throw new TypeError(FUNC_ERROR_TEXT);\n\t    }\n\t    wait = wait < 0 ? 0 : (+wait || 0);\n\t    if (options === true) {\n\t      var leading = true;\n\t      trailing = false;\n\t    } else if (isObject(options)) {\n\t      leading = !!options.leading;\n\t      maxWait = \'maxWait\' in options && nativeMax(+options.maxWait || 0, wait);\n\t      trailing = \'trailing\' in options ? !!options.trailing : trailing;\n\t    }\n\t\n\t    function cancel() {\n\t      if (timeoutId) {\n\t        clearTimeout(timeoutId);\n\t      }\n\t      if (maxTimeoutId) {\n\t        clearTimeout(maxTimeoutId);\n\t      }\n\t      lastCalled = 0;\n\t      maxTimeoutId = timeoutId = trailingCall = undefined;\n\t    }\n\t\n\t    function complete(isCalled, id) {\n\t      if (id) {\n\t        clearTimeout(id);\n\t      }\n\t      maxTimeoutId = timeoutId = trailingCall = undefined;\n\t      if (isCalled) {\n\t        lastCalled = now();\n\t        result = func.apply(thisArg, args);\n\t        if (!timeoutId && !maxTimeoutId) {\n\t          args = thisArg = undefined;\n\t        }\n\t      }\n\t    }\n\t\n\t    function delayed() {\n\t      var remaining = wait - (now() - stamp);\n\t      if (remaining <= 0 || remaining > wait) {\n\t        complete(trailingCall, maxTimeoutId);\n\t      } else {\n\t        timeoutId = setTimeout(delayed, remaining);\n\t      }\n\t    }\n\t\n\t    function maxDelayed() {\n\t      complete(trailing, timeoutId);\n\t    }\n\t\n\t    function debounced() {\n\t      args = arguments;\n\t      stamp = now();\n\t      thisArg = this;\n\t      trailingCall = trailing && (timeoutId || !leading);\n\t\n\t      if (maxWait === false) {\n\t        var leadingCall = leading && !timeoutId;\n\t      } else {\n\t        if (!maxTimeoutId && !leading) {\n\t          lastCalled = stamp;\n\t        }\n\t        var remaining = maxWait - (stamp - lastCalled),\n\t            isCalled = remaining <= 0 || remaining > maxWait;\n\t\n\t        if (isCalled) {\n\t          if (maxTimeoutId) {\n\t            maxTimeoutId = clearTimeout(maxTimeoutId);\n\t          }\n\t          lastCalled = stamp;\n\t          result = func.apply(thisArg, args);\n\t        }\n\t        else if (!maxTimeoutId) {\n\t          maxTimeoutId = setTimeout(maxDelayed, remaining);\n\t        }\n\t      }\n\t      if (isCalled && timeoutId) {\n\t        timeoutId = clearTimeout(timeoutId);\n\t      }\n\t      else if (!timeoutId && wait !== maxWait) {\n\t        timeoutId = setTimeout(delayed, wait);\n\t      }\n\t      if (leadingCall) {\n\t        isCalled = true;\n\t        result = func.apply(thisArg, args);\n\t      }\n\t      if (isCalled && !timeoutId && !maxTimeoutId) {\n\t        args = thisArg = undefined;\n\t      }\n\t      return result;\n\t    }\n\t    debounced.cancel = cancel;\n\t    return debounced;\n\t  }\n\t\n\t  /**\n\t   * Creates a function that invokes `func` with the `this` binding of the\n\t   * created function and arguments from `start` and beyond provided as an array.\n\t   *\n\t   * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Function\n\t   * @param {Function} func The function to apply a rest parameter to.\n\t   * @param {number} [start=func.length-1] The start position of the rest parameter.\n\t   * @returns {Function} Returns the new function.\n\t   * @example\n\t   *\n\t   * var say = _.restParam(function(what, names) {\n\t   *   return what + \' \' + _.initial(names).join(\', \') +\n\t   *     (_.size(names) > 1 ? \', & \' : \'\') + _.last(names);\n\t   * });\n\t   *\n\t   * say(\'hello\', \'fred\', \'barney\', \'pebbles\');\n\t   * // => \'hello fred, barney, & pebbles\'\n\t   */\n\t  function restParam(func, start) {\n\t    if (typeof func != \'function\') {\n\t      throw new TypeError(FUNC_ERROR_TEXT);\n\t    }\n\t    start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n\t    return function() {\n\t      var args = arguments,\n\t          index = -1,\n\t          length = nativeMax(args.length - start, 0),\n\t          rest = Array(length);\n\t\n\t      while (++index < length) {\n\t        rest[index] = args[start + index];\n\t      }\n\t      switch (start) {\n\t        case 0: return func.call(this, rest);\n\t        case 1: return func.call(this, args[0], rest);\n\t        case 2: return func.call(this, args[0], args[1], rest);\n\t      }\n\t      var otherArgs = Array(start + 1);\n\t      index = -1;\n\t      while (++index < start) {\n\t        otherArgs[index] = args[index];\n\t      }\n\t      otherArgs[start] = rest;\n\t      return func.apply(this, otherArgs);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a throttled function that only invokes `func` at most once per\n\t   * every `wait` milliseconds. The throttled function comes with a `cancel`\n\t   * method to cancel delayed invocations. Provide an options object to indicate\n\t   * that `func` should be invoked on the leading and/or trailing edge of the\n\t   * `wait` timeout. Subsequent calls to the throttled function return the\n\t   * result of the last `func` call.\n\t   *\n\t   * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t   * on the trailing edge of the timeout only if the the throttled function is\n\t   * invoked more than once during the `wait` timeout.\n\t   *\n\t   * See [David Corbacho\'s article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t   * for details over the differences between `_.throttle` and `_.debounce`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Function\n\t   * @param {Function} func The function to throttle.\n\t   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n\t   * @param {Object} [options] The options object.\n\t   * @param {boolean} [options.leading=true] Specify invoking on the leading\n\t   *  edge of the timeout.\n\t   * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t   *  edge of the timeout.\n\t   * @returns {Function} Returns the new throttled function.\n\t   * @example\n\t   *\n\t   * // avoid excessively updating the position while scrolling\n\t   * jQuery(window).on(\'scroll\', _.throttle(updatePosition, 100));\n\t   *\n\t   * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\n\t   * jQuery(\'.interactive\').on(\'click\', _.throttle(renewToken, 300000, {\n\t   *   \'trailing\': false\n\t   * }));\n\t   *\n\t   * // cancel a trailing throttled call\n\t   * jQuery(window).on(\'popstate\', throttled.cancel);\n\t   */\n\t  function throttle(func, wait, options) {\n\t    var leading = true,\n\t        trailing = true;\n\t\n\t    if (typeof func != \'function\') {\n\t      throw new TypeError(FUNC_ERROR_TEXT);\n\t    }\n\t    if (options === false) {\n\t      leading = false;\n\t    } else if (isObject(options)) {\n\t      leading = \'leading\' in options ? !!options.leading : leading;\n\t      trailing = \'trailing\' in options ? !!options.trailing : trailing;\n\t    }\n\t    return debounce(func, wait, { \'leading\': leading, \'maxWait\': +wait, \'trailing\': trailing });\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n\t   * otherwise they are assigned by reference. If `customizer` is provided it\'s\n\t   * invoked to produce the cloned values. If `customizer` returns `undefined`\n\t   * cloning is handled by the method instead. The `customizer` is bound to\n\t   * `thisArg` and invoked with up to three argument; (value [, index|key, object]).\n\t   *\n\t   * **Note:** This method is loosely based on the\n\t   * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n\t   * The enumerable properties of `arguments` objects and objects created by\n\t   * constructors other than `Object` are cloned to plain `Object` objects. An\n\t   * empty object is returned for uncloneable values such as functions, DOM nodes,\n\t   * Maps, Sets, and WeakMaps.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to clone.\n\t   * @param {boolean} [isDeep] Specify a deep clone.\n\t   * @param {Function} [customizer] The function to customize cloning values.\n\t   * @param {*} [thisArg] The `this` binding of `customizer`.\n\t   * @returns {*} Returns the cloned value.\n\t   * @example\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\' },\n\t   *   { \'user\': \'fred\' }\n\t   * ];\n\t   *\n\t   * var shallow = _.clone(users);\n\t   * shallow[0] === users[0];\n\t   * // => true\n\t   *\n\t   * var deep = _.clone(users, true);\n\t   * deep[0] === users[0];\n\t   * // => false\n\t   *\n\t   * // using a customizer callback\n\t   * var el = _.clone(document.body, function(value) {\n\t   *   if (_.isElement(value)) {\n\t   *     return value.cloneNode(false);\n\t   *   }\n\t   * });\n\t   *\n\t   * el === document.body\n\t   * // => false\n\t   * el.nodeName\n\t   * // => BODY\n\t   * el.childNodes.length;\n\t   * // => 0\n\t   */\n\t  function clone(value, isDeep, customizer, thisArg) {\n\t    if (isDeep && typeof isDeep != \'boolean\' && isIterateeCall(value, isDeep, customizer)) {\n\t      isDeep = false;\n\t    }\n\t    else if (typeof isDeep == \'function\') {\n\t      thisArg = customizer;\n\t      customizer = isDeep;\n\t      isDeep = false;\n\t    }\n\t    return typeof customizer == \'function\'\n\t      ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3))\n\t      : baseClone(value, isDeep);\n\t  }\n\t\n\t  /**\n\t   * Creates a deep clone of `value`. If `customizer` is provided it\'s invoked\n\t   * to produce the cloned values. If `customizer` returns `undefined` cloning\n\t   * is handled by the method instead. The `customizer` is bound to `thisArg`\n\t   * and invoked with up to three argument; (value [, index|key, object]).\n\t   *\n\t   * **Note:** This method is loosely based on the\n\t   * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n\t   * The enumerable properties of `arguments` objects and objects created by\n\t   * constructors other than `Object` are cloned to plain `Object` objects. An\n\t   * empty object is returned for uncloneable values such as functions, DOM nodes,\n\t   * Maps, Sets, and WeakMaps.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to deep clone.\n\t   * @param {Function} [customizer] The function to customize cloning values.\n\t   * @param {*} [thisArg] The `this` binding of `customizer`.\n\t   * @returns {*} Returns the deep cloned value.\n\t   * @example\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\' },\n\t   *   { \'user\': \'fred\' }\n\t   * ];\n\t   *\n\t   * var deep = _.cloneDeep(users);\n\t   * deep[0] === users[0];\n\t   * // => false\n\t   *\n\t   * // using a customizer callback\n\t   * var el = _.cloneDeep(document.body, function(value) {\n\t   *   if (_.isElement(value)) {\n\t   *     return value.cloneNode(true);\n\t   *   }\n\t   * });\n\t   *\n\t   * el === document.body\n\t   * // => false\n\t   * el.nodeName\n\t   * // => BODY\n\t   * el.childNodes.length;\n\t   * // => 20\n\t   */\n\t  function cloneDeep(value, customizer, thisArg) {\n\t    return typeof customizer == \'function\'\n\t      ? baseClone(value, true, bindCallback(customizer, thisArg, 3))\n\t      : baseClone(value, true);\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is greater than `other`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to compare.\n\t   * @param {*} other The other value to compare.\n\t   * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.\n\t   * @example\n\t   *\n\t   * _.gt(3, 1);\n\t   * // => true\n\t   *\n\t   * _.gt(3, 3);\n\t   * // => false\n\t   *\n\t   * _.gt(1, 3);\n\t   * // => false\n\t   */\n\t  function gt(value, other) {\n\t    return value > other;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is classified as an `arguments` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t   * @example\n\t   *\n\t   * _.isArguments(function() { return arguments; }());\n\t   * // => true\n\t   *\n\t   * _.isArguments([1, 2, 3]);\n\t   * // => false\n\t   */\n\t  function isArguments(value) {\n\t    return isObjectLike(value) && isArrayLike(value) &&\n\t      hasOwnProperty.call(value, \'callee\') && !propertyIsEnumerable.call(value, \'callee\');\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is classified as an `Array` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t   * @example\n\t   *\n\t   * _.isArray([1, 2, 3]);\n\t   * // => true\n\t   *\n\t   * _.isArray(function() { return arguments; }());\n\t   * // => false\n\t   */\n\t  var isArray = nativeIsArray || function(value) {\n\t    return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n\t  };\n\t\n\t  /**\n\t   * Checks if `value` is classified as a boolean primitive or object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t   * @example\n\t   *\n\t   * _.isBoolean(false);\n\t   * // => true\n\t   *\n\t   * _.isBoolean(null);\n\t   * // => false\n\t   */\n\t  function isBoolean(value) {\n\t    return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is empty. A value is considered empty unless it\'s an\n\t   * `arguments` object, array, string, or jQuery-like collection with a length\n\t   * greater than `0` or an object with own enumerable properties.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {Array|Object|string} value The value to inspect.\n\t   * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n\t   * @example\n\t   *\n\t   * _.isEmpty(null);\n\t   * // => true\n\t   *\n\t   * _.isEmpty(true);\n\t   * // => true\n\t   *\n\t   * _.isEmpty(1);\n\t   * // => true\n\t   *\n\t   * _.isEmpty([1, 2, 3]);\n\t   * // => false\n\t   *\n\t   * _.isEmpty({ \'a\': 1 });\n\t   * // => false\n\t   */\n\t  function isEmpty(value) {\n\t    if (value == null) {\n\t      return true;\n\t    }\n\t    if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||\n\t        (isObjectLike(value) && isFunction(value.splice)))) {\n\t      return !value.length;\n\t    }\n\t    return !keys(value).length;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n\t   * `SyntaxError`, `TypeError`, or `URIError` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n\t   * @example\n\t   *\n\t   * _.isError(new Error);\n\t   * // => true\n\t   *\n\t   * _.isError(Error);\n\t   * // => false\n\t   */\n\t  function isError(value) {\n\t    return isObjectLike(value) && typeof value.message == \'string\' && objToString.call(value) == errorTag;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is classified as a `Function` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t   * @example\n\t   *\n\t   * _.isFunction(_);\n\t   * // => true\n\t   *\n\t   * _.isFunction(/abc/);\n\t   * // => false\n\t   */\n\t  function isFunction(value) {\n\t    // The use of `Object#toString` avoids issues with the `typeof` operator\n\t    // in older versions of Chrome and Safari which return \'function\' for regexes\n\t    // and Safari 8 which returns \'object\' for typed array constructors.\n\t    return isObject(value) && objToString.call(value) == funcTag;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n\t   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String(\'\')`)\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t   * @example\n\t   *\n\t   * _.isObject({});\n\t   * // => true\n\t   *\n\t   * _.isObject([1, 2, 3]);\n\t   * // => true\n\t   *\n\t   * _.isObject(1);\n\t   * // => false\n\t   */\n\t  function isObject(value) {\n\t    // Avoid a V8 JIT bug in Chrome 19-20.\n\t    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t    var type = typeof value;\n\t    return !!value && (type == \'object\' || type == \'function\');\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is `NaN`.\n\t   *\n\t   * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)\n\t   * which returns `true` for `undefined` and other non-numeric values.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n\t   * @example\n\t   *\n\t   * _.isNaN(NaN);\n\t   * // => true\n\t   *\n\t   * _.isNaN(new Number(NaN));\n\t   * // => true\n\t   *\n\t   * isNaN(undefined);\n\t   * // => true\n\t   *\n\t   * _.isNaN(undefined);\n\t   * // => false\n\t   */\n\t  function isNaN(value) {\n\t    // An `NaN` primitive is the only value that is not equal to itself.\n\t    // Perform the `toStringTag` check first to avoid errors with some host objects in IE.\n\t    return isNumber(value) && value != +value;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is a native function.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n\t   * @example\n\t   *\n\t   * _.isNative(Array.prototype.push);\n\t   * // => true\n\t   *\n\t   * _.isNative(_);\n\t   * // => false\n\t   */\n\t  function isNative(value) {\n\t    if (value == null) {\n\t      return false;\n\t    }\n\t    if (isFunction(value)) {\n\t      return reIsNative.test(fnToString.call(value));\n\t    }\n\t    return isObjectLike(value) && reIsHostCtor.test(value);\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is `null`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n\t   * @example\n\t   *\n\t   * _.isNull(null);\n\t   * // => true\n\t   *\n\t   * _.isNull(void 0);\n\t   * // => false\n\t   */\n\t  function isNull(value) {\n\t    return value === null;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is classified as a `Number` primitive or object.\n\t   *\n\t   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n\t   * as numbers, use the `_.isFinite` method.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t   * @example\n\t   *\n\t   * _.isNumber(8.4);\n\t   * // => true\n\t   *\n\t   * _.isNumber(NaN);\n\t   * // => true\n\t   *\n\t   * _.isNumber(\'8.4\');\n\t   * // => false\n\t   */\n\t  function isNumber(value) {\n\t    return typeof value == \'number\' || (isObjectLike(value) && objToString.call(value) == numberTag);\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is a plain object, that is, an object created by the\n\t   * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t   *\n\t   * **Note:** This method assumes objects created by the `Object` constructor\n\t   * have no inherited enumerable properties.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n\t   * @example\n\t   *\n\t   * function Foo() {\n\t   *   this.a = 1;\n\t   * }\n\t   *\n\t   * _.isPlainObject(new Foo);\n\t   * // => false\n\t   *\n\t   * _.isPlainObject([1, 2, 3]);\n\t   * // => false\n\t   *\n\t   * _.isPlainObject({ \'x\': 0, \'y\': 0 });\n\t   * // => true\n\t   *\n\t   * _.isPlainObject(Object.create(null));\n\t   * // => true\n\t   */\n\t  function isPlainObject(value) {\n\t    var Ctor;\n\t\n\t    // Exit early for non `Object` objects.\n\t    if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||\n\t        (!hasOwnProperty.call(value, \'constructor\') && (Ctor = value.constructor, typeof Ctor == \'function\' && !(Ctor instanceof Ctor)))) {\n\t      return false;\n\t    }\n\t    // IE < 9 iterates inherited properties before own properties. If the first\n\t    // iterated property is an object\'s own property then there are no inherited\n\t    // enumerable properties.\n\t    var result;\n\t    // In most environments an object\'s own properties are iterated before\n\t    // its inherited properties. If the last iterated property is an object\'s\n\t    // own property then there are no inherited enumerable properties.\n\t    baseForIn(value, function(subValue, key) {\n\t      result = key;\n\t    });\n\t    return result === undefined || hasOwnProperty.call(value, result);\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is classified as a `String` primitive or object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t   * @example\n\t   *\n\t   * _.isString(\'abc\');\n\t   * // => true\n\t   *\n\t   * _.isString(1);\n\t   * // => false\n\t   */\n\t  function isString(value) {\n\t    return typeof value == \'string\' || (isObjectLike(value) && objToString.call(value) == stringTag);\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is classified as a typed array.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t   * @example\n\t   *\n\t   * _.isTypedArray(new Uint8Array);\n\t   * // => true\n\t   *\n\t   * _.isTypedArray([]);\n\t   * // => false\n\t   */\n\t  function isTypedArray(value) {\n\t    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is `undefined`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n\t   * @example\n\t   *\n\t   * _.isUndefined(void 0);\n\t   * // => true\n\t   *\n\t   * _.isUndefined(null);\n\t   * // => false\n\t   */\n\t  function isUndefined(value) {\n\t    return value === undefined;\n\t  }\n\t\n\t  /**\n\t   * Converts `value` to a plain object flattening inherited enumerable\n\t   * properties of `value` to own properties of the plain object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Lang\n\t   * @param {*} value The value to convert.\n\t   * @returns {Object} Returns the converted plain object.\n\t   * @example\n\t   *\n\t   * function Foo() {\n\t   *   this.b = 2;\n\t   * }\n\t   *\n\t   * Foo.prototype.c = 3;\n\t   *\n\t   * _.assign({ \'a\': 1 }, new Foo);\n\t   * // => { \'a\': 1, \'b\': 2 }\n\t   *\n\t   * _.assign({ \'a\': 1 }, _.toPlainObject(new Foo));\n\t   * // => { \'a\': 1, \'b\': 2, \'c\': 3 }\n\t   */\n\t  function toPlainObject(value) {\n\t    return baseCopy(value, keysIn(value));\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Recursively merges own enumerable properties of the source object(s), that\n\t   * don\'t resolve to `undefined` into the destination object. Subsequent sources\n\t   * overwrite property assignments of previous sources. If `customizer` is\n\t   * provided it\'s invoked to produce the merged values of the destination and\n\t   * source properties. If `customizer` returns `undefined` merging is handled\n\t   * by the method instead. The `customizer` is bound to `thisArg` and invoked\n\t   * with five arguments: (objectValue, sourceValue, key, object, source).\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The destination object.\n\t   * @param {...Object} [sources] The source objects.\n\t   * @param {Function} [customizer] The function to customize assigned values.\n\t   * @param {*} [thisArg] The `this` binding of `customizer`.\n\t   * @returns {Object} Returns `object`.\n\t   * @example\n\t   *\n\t   * var users = {\n\t   *   \'data\': [{ \'user\': \'barney\' }, { \'user\': \'fred\' }]\n\t   * };\n\t   *\n\t   * var ages = {\n\t   *   \'data\': [{ \'age\': 36 }, { \'age\': 40 }]\n\t   * };\n\t   *\n\t   * _.merge(users, ages);\n\t   * // => { \'data\': [{ \'user\': \'barney\', \'age\': 36 }, { \'user\': \'fred\', \'age\': 40 }] }\n\t   *\n\t   * // using a customizer callback\n\t   * var object = {\n\t   *   \'fruits\': [\'apple\'],\n\t   *   \'vegetables\': [\'beet\']\n\t   * };\n\t   *\n\t   * var other = {\n\t   *   \'fruits\': [\'banana\'],\n\t   *   \'vegetables\': [\'carrot\']\n\t   * };\n\t   *\n\t   * _.merge(object, other, function(a, b) {\n\t   *   if (_.isArray(a)) {\n\t   *     return a.concat(b);\n\t   *   }\n\t   * });\n\t   * // => { \'fruits\': [\'apple\', \'banana\'], \'vegetables\': [\'beet\', \'carrot\'] }\n\t   */\n\t  var merge = createAssigner(baseMerge);\n\t\n\t  /**\n\t   * Assigns own enumerable properties of source object(s) to the destination\n\t   * object. Subsequent sources overwrite property assignments of previous sources.\n\t   * If `customizer` is provided it\'s invoked to produce the assigned values.\n\t   * The `customizer` is bound to `thisArg` and invoked with five arguments:\n\t   * (objectValue, sourceValue, key, object, source).\n\t   *\n\t   * **Note:** This method mutates `object` and is based on\n\t   * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias extend\n\t   * @category Object\n\t   * @param {Object} object The destination object.\n\t   * @param {...Object} [sources] The source objects.\n\t   * @param {Function} [customizer] The function to customize assigned values.\n\t   * @param {*} [thisArg] The `this` binding of `customizer`.\n\t   * @returns {Object} Returns `object`.\n\t   * @example\n\t   *\n\t   * _.assign({ \'user\': \'barney\' }, { \'age\': 40 }, { \'user\': \'fred\' });\n\t   * // => { \'user\': \'fred\', \'age\': 40 }\n\t   *\n\t   * // using a customizer callback\n\t   * var defaults = _.partialRight(_.assign, function(value, other) {\n\t   *   return _.isUndefined(value) ? other : value;\n\t   * });\n\t   *\n\t   * defaults({ \'user\': \'barney\' }, { \'age\': 36 }, { \'user\': \'fred\' });\n\t   * // => { \'user\': \'barney\', \'age\': 36 }\n\t   */\n\t  var assign = createAssigner(function(object, source, customizer) {\n\t    return customizer\n\t      ? assignWith(object, source, customizer)\n\t      : baseAssign(object, source);\n\t  });\n\t\n\t  /**\n\t   * Creates an object that inherits from the given `prototype` object. If a\n\t   * `properties` object is provided its own enumerable properties are assigned\n\t   * to the created object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} prototype The object to inherit from.\n\t   * @param {Object} [properties] The properties to assign to the object.\n\t   * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t   * @returns {Object} Returns the new object.\n\t   * @example\n\t   *\n\t   * function Shape() {\n\t   *   this.x = 0;\n\t   *   this.y = 0;\n\t   * }\n\t   *\n\t   * function Circle() {\n\t   *   Shape.call(this);\n\t   * }\n\t   *\n\t   * Circle.prototype = _.create(Shape.prototype, {\n\t   *   \'constructor\': Circle\n\t   * });\n\t   *\n\t   * var circle = new Circle;\n\t   * circle instanceof Circle;\n\t   * // => true\n\t   *\n\t   * circle instanceof Shape;\n\t   * // => true\n\t   */\n\t  function create(prototype, properties, guard) {\n\t    var result = baseCreate(prototype);\n\t    if (guard && isIterateeCall(prototype, properties, guard)) {\n\t      properties = undefined;\n\t    }\n\t    return properties ? baseAssign(result, properties) : result;\n\t  }\n\t\n\t  /**\n\t   * Assigns own enumerable properties of source object(s) to the destination\n\t   * object for all destination properties that resolve to `undefined`. Once a\n\t   * property is set, additional values of the same property are ignored.\n\t   *\n\t   * **Note:** This method mutates `object`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The destination object.\n\t   * @param {...Object} [sources] The source objects.\n\t   * @returns {Object} Returns `object`.\n\t   * @example\n\t   *\n\t   * _.defaults({ \'user\': \'barney\' }, { \'age\': 36 }, { \'user\': \'fred\' });\n\t   * // => { \'user\': \'barney\', \'age\': 36 }\n\t   */\n\t  var defaults = createDefaults(assign, assignDefaults);\n\t\n\t  /**\n\t   * This method is like `_.defaults` except that it recursively assigns\n\t   * default properties.\n\t   *\n\t   * **Note:** This method mutates `object`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The destination object.\n\t   * @param {...Object} [sources] The source objects.\n\t   * @returns {Object} Returns `object`.\n\t   * @example\n\t   *\n\t   * _.defaultsDeep({ \'user\': { \'name\': \'barney\' } }, { \'user\': { \'name\': \'fred\', \'age\': 36 } });\n\t   * // => { \'user\': { \'name\': \'barney\', \'age\': 36 } }\n\t   *\n\t   */\n\t  var defaultsDeep = createDefaults(merge, mergeDefaults);\n\t\n\t  /**\n\t   * Iterates over own enumerable properties of an object invoking `iteratee`\n\t   * for each property. The `iteratee` is bound to `thisArg` and invoked with\n\t   * three arguments: (value, key, object). Iteratee functions may exit iteration\n\t   * early by explicitly returning `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to iterate over.\n\t   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {Object} Returns `object`.\n\t   * @example\n\t   *\n\t   * function Foo() {\n\t   *   this.a = 1;\n\t   *   this.b = 2;\n\t   * }\n\t   *\n\t   * Foo.prototype.c = 3;\n\t   *\n\t   * _.forOwn(new Foo, function(value, key) {\n\t   *   console.log(key);\n\t   * });\n\t   * // => logs \'a\' and \'b\' (iteration order is not guaranteed)\n\t   */\n\t  var forOwn = createForOwn(baseForOwn);\n\t\n\t  /**\n\t   * Creates an array of function property names from all enumerable properties,\n\t   * own and inherited, of `object`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias methods\n\t   * @category Object\n\t   * @param {Object} object The object to inspect.\n\t   * @returns {Array} Returns the new array of property names.\n\t   * @example\n\t   *\n\t   * _.functions(_);\n\t   * // => [\'after\', \'ary\', \'assign\', ...]\n\t   */\n\t  function functions(object) {\n\t    return baseFunctions(object, keysIn(object));\n\t  }\n\t\n\t  /**\n\t   * Gets the property value at `path` of `object`. If the resolved value is\n\t   * `undefined` the `defaultValue` is used in its place.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to query.\n\t   * @param {Array|string} path The path of the property to get.\n\t   * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n\t   * @returns {*} Returns the resolved value.\n\t   * @example\n\t   *\n\t   * var object = { \'a\': [{ \'b\': { \'c\': 3 } }] };\n\t   *\n\t   * _.get(object, \'a[0].b.c\');\n\t   * // => 3\n\t   *\n\t   * _.get(object, [\'a\', \'0\', \'b\', \'c\']);\n\t   * // => 3\n\t   *\n\t   * _.get(object, \'a.b.c\', \'default\');\n\t   * // => \'default\'\n\t   */\n\t  function get(object, path, defaultValue) {\n\t    var result = object == null ? undefined : baseGet(object, toPath(path), (path + \'\'));\n\t    return result === undefined ? defaultValue : result;\n\t  }\n\t\n\t  /**\n\t   * Creates an object composed of the inverted keys and values of `object`.\n\t   * If `object` contains duplicate values, subsequent values overwrite property\n\t   * assignments of previous values unless `multiValue` is `true`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to invert.\n\t   * @param {boolean} [multiValue] Allow multiple values per key.\n\t   * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t   * @returns {Object} Returns the new inverted object.\n\t   * @example\n\t   *\n\t   * var object = { \'a\': 1, \'b\': 2, \'c\': 1 };\n\t   *\n\t   * _.invert(object);\n\t   * // => { \'1\': \'c\', \'2\': \'b\' }\n\t   *\n\t   * // with `multiValue`\n\t   * _.invert(object, true);\n\t   * // => { \'1\': [\'a\', \'c\'], \'2\': [\'b\'] }\n\t   */\n\t  function invert(object, multiValue, guard) {\n\t    if (guard && isIterateeCall(object, multiValue, guard)) {\n\t      multiValue = undefined;\n\t    }\n\t    var index = -1,\n\t        props = keys(object),\n\t        length = props.length,\n\t        result = {};\n\t\n\t    while (++index < length) {\n\t      var key = props[index],\n\t          value = object[key];\n\t\n\t      if (multiValue) {\n\t        if (hasOwnProperty.call(result, value)) {\n\t          result[value].push(key);\n\t        } else {\n\t          result[value] = [key];\n\t        }\n\t      }\n\t      else {\n\t        result[value] = key;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Creates an array of the own enumerable property names of `object`.\n\t   *\n\t   * **Note:** Non-object values are coerced to objects. See the\n\t   * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n\t   * for more details.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to query.\n\t   * @returns {Array} Returns the array of property names.\n\t   * @example\n\t   *\n\t   * function Foo() {\n\t   *   this.a = 1;\n\t   *   this.b = 2;\n\t   * }\n\t   *\n\t   * Foo.prototype.c = 3;\n\t   *\n\t   * _.keys(new Foo);\n\t   * // => [\'a\', \'b\'] (iteration order is not guaranteed)\n\t   *\n\t   * _.keys(\'hi\');\n\t   * // => [\'0\', \'1\']\n\t   */\n\t  var keys = !nativeKeys ? shimKeys : function(object) {\n\t    var Ctor = object == null ? undefined : object.constructor;\n\t    if ((typeof Ctor == \'function\' && Ctor.prototype === object) ||\n\t        (typeof object != \'function\' && isArrayLike(object))) {\n\t      return shimKeys(object);\n\t    }\n\t    return isObject(object) ? nativeKeys(object) : [];\n\t  };\n\t\n\t  /**\n\t   * Creates an array of the own and inherited enumerable property names of `object`.\n\t   *\n\t   * **Note:** Non-object values are coerced to objects.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to query.\n\t   * @returns {Array} Returns the array of property names.\n\t   * @example\n\t   *\n\t   * function Foo() {\n\t   *   this.a = 1;\n\t   *   this.b = 2;\n\t   * }\n\t   *\n\t   * Foo.prototype.c = 3;\n\t   *\n\t   * _.keysIn(new Foo);\n\t   * // => [\'a\', \'b\', \'c\'] (iteration order is not guaranteed)\n\t   */\n\t  function keysIn(object) {\n\t    if (object == null) {\n\t      return [];\n\t    }\n\t    if (!isObject(object)) {\n\t      object = Object(object);\n\t    }\n\t    var length = object.length;\n\t    length = (length && isLength(length) &&\n\t      (isArray(object) || isArguments(object)) && length) || 0;\n\t\n\t    var Ctor = object.constructor,\n\t        index = -1,\n\t        isProto = typeof Ctor == \'function\' && Ctor.prototype === object,\n\t        result = Array(length),\n\t        skipIndexes = length > 0;\n\t\n\t    while (++index < length) {\n\t      result[index] = (index + \'\');\n\t    }\n\t    for (var key in object) {\n\t      if (!(skipIndexes && isIndex(key, length)) &&\n\t          !(key == \'constructor\' && (isProto || !hasOwnProperty.call(object, key)))) {\n\t        result.push(key);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The opposite of `_.mapValues`; this method creates an object with the\n\t   * same values as `object` and keys generated by running each own enumerable\n\t   * property of `object` through `iteratee`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to iterate over.\n\t   * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {Object} Returns the new mapped object.\n\t   * @example\n\t   *\n\t   * _.mapKeys({ \'a\': 1, \'b\': 2 }, function(value, key) {\n\t   *   return key + value;\n\t   * });\n\t   * // => { \'a1\': 1, \'b2\': 2 }\n\t   */\n\t  var mapKeys = createObjectMapper(true);\n\t\n\t  /**\n\t   * Creates an object with the same keys as `object` and values generated by\n\t   * running each own enumerable property of `object` through `iteratee`. The\n\t   * iteratee function is bound to `thisArg` and invoked with three arguments:\n\t   * (value, key, object).\n\t   *\n\t   * If a property name is provided for `iteratee` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `iteratee` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to iterate over.\n\t   * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t   *  per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {Object} Returns the new mapped object.\n\t   * @example\n\t   *\n\t   * _.mapValues({ \'a\': 1, \'b\': 2 }, function(n) {\n\t   *   return n * 3;\n\t   * });\n\t   * // => { \'a\': 3, \'b\': 6 }\n\t   *\n\t   * var users = {\n\t   *   \'fred\':    { \'user\': \'fred\',    \'age\': 40 },\n\t   *   \'pebbles\': { \'user\': \'pebbles\', \'age\': 1 }\n\t   * };\n\t   *\n\t   * // using the `_.property` callback shorthand\n\t   * _.mapValues(users, \'age\');\n\t   * // => { \'fred\': 40, \'pebbles\': 1 } (iteration order is not guaranteed)\n\t   */\n\t  var mapValues = createObjectMapper();\n\t\n\t  /**\n\t   * The opposite of `_.pick`; this method creates an object composed of the\n\t   * own and inherited enumerable properties of `object` that are not omitted.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The source object.\n\t   * @param {Function|...(string|string[])} [predicate] The function invoked per\n\t   *  iteration or property names to omit, specified as individual property\n\t   *  names or arrays of property names.\n\t   * @param {*} [thisArg] The `this` binding of `predicate`.\n\t   * @returns {Object} Returns the new object.\n\t   * @example\n\t   *\n\t   * var object = { \'user\': \'fred\', \'age\': 40 };\n\t   *\n\t   * _.omit(object, \'age\');\n\t   * // => { \'user\': \'fred\' }\n\t   *\n\t   * _.omit(object, _.isNumber);\n\t   * // => { \'user\': \'fred\' }\n\t   */\n\t  var omit = restParam(function(object, props) {\n\t    if (object == null) {\n\t      return {};\n\t    }\n\t    if (typeof props[0] != \'function\') {\n\t      var props = arrayMap(baseFlatten(props), String);\n\t      return pickByArray(object, baseDifference(keysIn(object), props));\n\t    }\n\t    var predicate = bindCallback(props[0], props[1], 3);\n\t    return pickByCallback(object, function(value, key, object) {\n\t      return !predicate(value, key, object);\n\t    });\n\t  });\n\t\n\t  /**\n\t   * Creates a two dimensional array of the key-value pairs for `object`,\n\t   * e.g. `[[key1, value1], [key2, value2]]`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to query.\n\t   * @returns {Array} Returns the new array of key-value pairs.\n\t   * @example\n\t   *\n\t   * _.pairs({ \'barney\': 36, \'fred\': 40 });\n\t   * // => [[\'barney\', 36], [\'fred\', 40]] (iteration order is not guaranteed)\n\t   */\n\t  function pairs(object) {\n\t    object = toObject(object);\n\t\n\t    var index = -1,\n\t        props = keys(object),\n\t        length = props.length,\n\t        result = Array(length);\n\t\n\t    while (++index < length) {\n\t      var key = props[index];\n\t      result[index] = [key, object[key]];\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Creates an object composed of the picked `object` properties. Property\n\t   * names may be specified as individual arguments or as arrays of property\n\t   * names. If `predicate` is provided it\'s invoked for each property of `object`\n\t   * picking the properties `predicate` returns truthy for. The predicate is\n\t   * bound to `thisArg` and invoked with three arguments: (value, key, object).\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The source object.\n\t   * @param {Function|...(string|string[])} [predicate] The function invoked per\n\t   *  iteration or property names to pick, specified as individual property\n\t   *  names or arrays of property names.\n\t   * @param {*} [thisArg] The `this` binding of `predicate`.\n\t   * @returns {Object} Returns the new object.\n\t   * @example\n\t   *\n\t   * var object = { \'user\': \'fred\', \'age\': 40 };\n\t   *\n\t   * _.pick(object, \'user\');\n\t   * // => { \'user\': \'fred\' }\n\t   *\n\t   * _.pick(object, _.isString);\n\t   * // => { \'user\': \'fred\' }\n\t   */\n\t  var pick = restParam(function(object, props) {\n\t    if (object == null) {\n\t      return {};\n\t    }\n\t    return typeof props[0] == \'function\'\n\t      ? pickByCallback(object, bindCallback(props[0], props[1], 3))\n\t      : pickByArray(object, baseFlatten(props));\n\t  });\n\t\n\t  /**\n\t   * Sets the property value of `path` on `object`. If a portion of `path`\n\t   * does not exist it\'s created.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to augment.\n\t   * @param {Array|string} path The path of the property to set.\n\t   * @param {*} value The value to set.\n\t   * @returns {Object} Returns `object`.\n\t   * @example\n\t   *\n\t   * var object = { \'a\': [{ \'b\': { \'c\': 3 } }] };\n\t   *\n\t   * _.set(object, \'a[0].b.c\', 4);\n\t   * console.log(object.a[0].b.c);\n\t   * // => 4\n\t   *\n\t   * _.set(object, \'x[0].y.z\', 5);\n\t   * console.log(object.x[0].y.z);\n\t   * // => 5\n\t   */\n\t  function set(object, path, value) {\n\t    if (object == null) {\n\t      return object;\n\t    }\n\t    var pathKey = (path + \'\');\n\t    path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);\n\t\n\t    var index = -1,\n\t        length = path.length,\n\t        lastIndex = length - 1,\n\t        nested = object;\n\t\n\t    while (nested != null && ++index < length) {\n\t      var key = path[index];\n\t      if (isObject(nested)) {\n\t        if (index == lastIndex) {\n\t          nested[key] = value;\n\t        } else if (nested[key] == null) {\n\t          nested[key] = isIndex(path[index + 1]) ? [] : {};\n\t        }\n\t      }\n\t      nested = nested[key];\n\t    }\n\t    return object;\n\t  }\n\t\n\t  /**\n\t   * Creates an array of the own enumerable property values of `object`.\n\t   *\n\t   * **Note:** Non-object values are coerced to objects.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Object\n\t   * @param {Object} object The object to query.\n\t   * @returns {Array} Returns the array of property values.\n\t   * @example\n\t   *\n\t   * function Foo() {\n\t   *   this.a = 1;\n\t   *   this.b = 2;\n\t   * }\n\t   *\n\t   * Foo.prototype.c = 3;\n\t   *\n\t   * _.values(new Foo);\n\t   * // => [1, 2] (iteration order is not guaranteed)\n\t   *\n\t   * _.values(\'hi\');\n\t   * // => [\'h\', \'i\']\n\t   */\n\t  function values(object) {\n\t    return baseValues(object, keys(object));\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Produces a random number between `min` and `max` (inclusive). If only one\n\t   * argument is provided a number between `0` and the given number is returned.\n\t   * If `floating` is `true`, or either `min` or `max` are floats, a floating-point\n\t   * number is returned instead of an integer.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Number\n\t   * @param {number} [min=0] The minimum possible value.\n\t   * @param {number} [max=1] The maximum possible value.\n\t   * @param {boolean} [floating] Specify returning a floating-point number.\n\t   * @returns {number} Returns the random number.\n\t   * @example\n\t   *\n\t   * _.random(0, 5);\n\t   * // => an integer between 0 and 5\n\t   *\n\t   * _.random(5);\n\t   * // => also an integer between 0 and 5\n\t   *\n\t   * _.random(5, true);\n\t   * // => a floating-point number between 0 and 5\n\t   *\n\t   * _.random(1.2, 5.2);\n\t   * // => a floating-point number between 1.2 and 5.2\n\t   */\n\t  function random(min, max, floating) {\n\t    if (floating && isIterateeCall(min, max, floating)) {\n\t      max = floating = undefined;\n\t    }\n\t    var noMin = min == null,\n\t        noMax = max == null;\n\t\n\t    if (floating == null) {\n\t      if (noMax && typeof min == \'boolean\') {\n\t        floating = min;\n\t        min = 1;\n\t      }\n\t      else if (typeof max == \'boolean\') {\n\t        floating = max;\n\t        noMax = true;\n\t      }\n\t    }\n\t    if (noMin && noMax) {\n\t      max = 1;\n\t      noMax = false;\n\t    }\n\t    min = +min || 0;\n\t    if (noMax) {\n\t      max = min;\n\t      min = 0;\n\t    } else {\n\t      max = +max || 0;\n\t    }\n\t    if (floating || min % 1 || max % 1) {\n\t      var rand = nativeRandom();\n\t      return nativeMin(min + (rand * (max - min + parseFloat(\'1e-\' + ((rand + \'\').length - 1)))), max);\n\t    }\n\t    return baseRandom(min, max);\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Checks if `string` ends with the given target string.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category String\n\t   * @param {string} [string=\'\'] The string to search.\n\t   * @param {string} [target] The string to search for.\n\t   * @param {number} [position=string.length] The position to search from.\n\t   * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\n\t   * @example\n\t   *\n\t   * _.endsWith(\'abc\', \'c\');\n\t   * // => true\n\t   *\n\t   * _.endsWith(\'abc\', \'b\');\n\t   * // => false\n\t   *\n\t   * _.endsWith(\'abc\', \'b\', 2);\n\t   * // => true\n\t   */\n\t  function endsWith(string, target, position) {\n\t    string = baseToString(string);\n\t    target = (target + \'\');\n\t\n\t    var length = string.length;\n\t    position = position === undefined\n\t      ? length\n\t      : nativeMin(position < 0 ? 0 : (+position || 0), length);\n\t\n\t    position -= target.length;\n\t    return position >= 0 && string.indexOf(target, position) == position;\n\t  }\n\t\n\t  /**\n\t   * Converts the characters "&", "<", ">", \'"\', "\'", and "\\`", in `string` to\n\t   * their corresponding HTML entities.\n\t   *\n\t   * **Note:** No other characters are escaped. To escape additional characters\n\t   * use a third-party library like [_he_](https://mths.be/he).\n\t   *\n\t   * Though the ">" character is escaped for symmetry, characters like\n\t   * ">" and "/" don\'t need escaping in HTML and have no special meaning\n\t   * unless they\'re part of a tag or unquoted attribute value.\n\t   * See [Mathias Bynens\'s article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n\t   * (under "semi-related fun fact") for more details.\n\t   *\n\t   * Backticks are escaped because in Internet Explorer < 9, they can break out\n\t   * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),\n\t   * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\n\t   * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)\n\t   * for more details.\n\t   *\n\t   * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)\n\t   * to reduce XSS vectors.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category String\n\t   * @param {string} [string=\'\'] The string to escape.\n\t   * @returns {string} Returns the escaped string.\n\t   * @example\n\t   *\n\t   * _.escape(\'fred, barney, & pebbles\');\n\t   * // => \'fred, barney, &amp; pebbles\'\n\t   */\n\t  function escape(string) {\n\t    // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n\t    string = baseToString(string);\n\t    return (string && reHasUnescapedHtml.test(string))\n\t      ? string.replace(reUnescapedHtml, escapeHtmlChar)\n\t      : string;\n\t  }\n\t\n\t  /**\n\t   * Pads `string` on the left side if it\'s shorter than `length`. Padding\n\t   * characters are truncated if they exceed `length`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category String\n\t   * @param {string} [string=\'\'] The string to pad.\n\t   * @param {number} [length=0] The padding length.\n\t   * @param {string} [chars=\' \'] The string used as padding.\n\t   * @returns {string} Returns the padded string.\n\t   * @example\n\t   *\n\t   * _.padLeft(\'abc\', 6);\n\t   * // => \'   abc\'\n\t   *\n\t   * _.padLeft(\'abc\', 6, \'_-\');\n\t   * // => \'_-_abc\'\n\t   *\n\t   * _.padLeft(\'abc\', 3);\n\t   * // => \'abc\'\n\t   */\n\t  var padLeft = createPadDir();\n\t\n\t  /**\n\t   * Repeats the given string `n` times.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category String\n\t   * @param {string} [string=\'\'] The string to repeat.\n\t   * @param {number} [n=0] The number of times to repeat the string.\n\t   * @returns {string} Returns the repeated string.\n\t   * @example\n\t   *\n\t   * _.repeat(\'*\', 3);\n\t   * // => \'***\'\n\t   *\n\t   * _.repeat(\'abc\', 2);\n\t   * // => \'abcabc\'\n\t   *\n\t   * _.repeat(\'abc\', 0);\n\t   * // => \'\'\n\t   */\n\t  function repeat(string, n) {\n\t    var result = \'\';\n\t    string = baseToString(string);\n\t    n = +n;\n\t    if (n < 1 || !string || !nativeIsFinite(n)) {\n\t      return result;\n\t    }\n\t    // Leverage the exponentiation by squaring algorithm for a faster repeat.\n\t    // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n\t    do {\n\t      if (n % 2) {\n\t        result += string;\n\t      }\n\t      n = nativeFloor(n / 2);\n\t      string += string;\n\t    } while (n);\n\t\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Checks if `string` starts with the given target string.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category String\n\t   * @param {string} [string=\'\'] The string to search.\n\t   * @param {string} [target] The string to search for.\n\t   * @param {number} [position=0] The position to search from.\n\t   * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\n\t   * @example\n\t   *\n\t   * _.startsWith(\'abc\', \'a\');\n\t   * // => true\n\t   *\n\t   * _.startsWith(\'abc\', \'b\');\n\t   * // => false\n\t   *\n\t   * _.startsWith(\'abc\', \'b\', 1);\n\t   * // => true\n\t   */\n\t  function startsWith(string, target, position) {\n\t    string = baseToString(string);\n\t    position = position == null\n\t      ? 0\n\t      : nativeMin(position < 0 ? 0 : (+position || 0), string.length);\n\t\n\t    return string.lastIndexOf(target, position) == position;\n\t  }\n\t\n\t  /**\n\t   * Creates a compiled template function that can interpolate data properties\n\t   * in "interpolate" delimiters, HTML-escape interpolated data properties in\n\t   * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data\n\t   * properties may be accessed as free variables in the template. If a setting\n\t   * object is provided it takes precedence over `_.templateSettings` values.\n\t   *\n\t   * **Note:** In the development build `_.template` utilizes\n\t   * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n\t   * for easier debugging.\n\t   *\n\t   * For more information on precompiling templates see\n\t   * [lodash\'s custom builds documentation](https://lodash.com/custom-builds).\n\t   *\n\t   * For more information on Chrome extension sandboxes see\n\t   * [Chrome\'s extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category String\n\t   * @param {string} [string=\'\'] The template string.\n\t   * @param {Object} [options] The options object.\n\t   * @param {RegExp} [options.escape] The HTML "escape" delimiter.\n\t   * @param {RegExp} [options.evaluate] The "evaluate" delimiter.\n\t   * @param {Object} [options.imports] An object to import into the template as free variables.\n\t   * @param {RegExp} [options.interpolate] The "interpolate" delimiter.\n\t   * @param {string} [options.sourceURL] The sourceURL of the template\'s compiled source.\n\t   * @param {string} [options.variable] The data object variable name.\n\t   * @param- {Object} [otherOptions] Enables the legacy `options` param signature.\n\t   * @returns {Function} Returns the compiled template function.\n\t   * @example\n\t   *\n\t   * // using the "interpolate" delimiter to create a compiled template\n\t   * var compiled = _.template(\'hello <%= user %>!\');\n\t   * compiled({ \'user\': \'fred\' });\n\t   * // => \'hello fred!\'\n\t   *\n\t   * // using the HTML "escape" delimiter to escape data property values\n\t   * var compiled = _.template(\'<b><%- value %></b>\');\n\t   * compiled({ \'value\': \'<script>\' });\n\t   * // => \'<b>&lt;script&gt;</b>\'\n\t   *\n\t   * // using the "evaluate" delimiter to execute JavaScript and generate HTML\n\t   * var compiled = _.template(\'<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>\');\n\t   * compiled({ \'users\': [\'fred\', \'barney\'] });\n\t   * // => \'<li>fred</li><li>barney</li>\'\n\t   *\n\t   * // using the internal `print` function in "evaluate" delimiters\n\t   * var compiled = _.template(\'<% print("hello " + user); %>!\');\n\t   * compiled({ \'user\': \'barney\' });\n\t   * // => \'hello barney!\'\n\t   *\n\t   * // using the ES delimiter as an alternative to the default "interpolate" delimiter\n\t   * var compiled = _.template(\'hello ${ user }!\');\n\t   * compiled({ \'user\': \'pebbles\' });\n\t   * // => \'hello pebbles!\'\n\t   *\n\t   * // using custom template delimiters\n\t   * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n\t   * var compiled = _.template(\'hello {{ user }}!\');\n\t   * compiled({ \'user\': \'mustache\' });\n\t   * // => \'hello mustache!\'\n\t   *\n\t   * // using backslashes to treat delimiters as plain text\n\t   * var compiled = _.template(\'<%= "\\\\<%- value %\\\\>" %>\');\n\t   * compiled({ \'value\': \'ignored\' });\n\t   * // => \'<%- value %>\'\n\t   *\n\t   * // using the `imports` option to import `jQuery` as `jq`\n\t   * var text = \'<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>\';\n\t   * var compiled = _.template(text, { \'imports\': { \'jq\': jQuery } });\n\t   * compiled({ \'users\': [\'fred\', \'barney\'] });\n\t   * // => \'<li>fred</li><li>barney</li>\'\n\t   *\n\t   * // using the `sourceURL` option to specify a custom sourceURL for the template\n\t   * var compiled = _.template(\'hello <%= user %>!\', { \'sourceURL\': \'/basic/greeting.jst\' });\n\t   * compiled(data);\n\t   * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector\n\t   *\n\t   * // using the `variable` option to ensure a with-statement isn\'t used in the compiled template\n\t   * var compiled = _.template(\'hi <%= data.user %>!\', { \'variable\': \'data\' });\n\t   * compiled.source;\n\t   * // => function(data) {\n\t   * //   var __t, __p = \'\';\n\t   * //   __p += \'hi \' + ((__t = ( data.user )) == null ? \'\' : __t) + \'!\';\n\t   * //   return __p;\n\t   * // }\n\t   *\n\t   * // using the `source` property to inline compiled templates for meaningful\n\t   * // line numbers in error messages and a stack trace\n\t   * fs.writeFileSync(path.join(cwd, \'jst.js\'), \'\\\n\t   *   var JST = {\\\n\t   *     "main": \' + _.template(mainText).source + \'\\\n\t   *   };\\\n\t   * \');\n\t   */\n\t  function template(string, options, otherOptions) {\n\t    // Based on John Resig\'s `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\n\t    // and Laura Doktorova\'s doT.js (https://github.com/olado/doT).\n\t    var settings = lodash.templateSettings;\n\t\n\t    if (otherOptions && isIterateeCall(string, options, otherOptions)) {\n\t      options = otherOptions = undefined;\n\t    }\n\t    string = baseToString(string);\n\t    options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);\n\t\n\t    var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),\n\t        importsKeys = keys(imports),\n\t        importsValues = baseValues(imports, importsKeys);\n\t\n\t    var isEscaping,\n\t        isEvaluating,\n\t        index = 0,\n\t        interpolate = options.interpolate || reNoMatch,\n\t        source = "__p += \'";\n\t\n\t    // Compile the regexp to match each delimiter.\n\t    var reDelimiters = RegExp(\n\t      (options.escape || reNoMatch).source + \'|\' +\n\t      interpolate.source + \'|\' +\n\t      (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + \'|\' +\n\t      (options.evaluate || reNoMatch).source + \'|$\'\n\t    , \'g\');\n\t\n\t    // Use a sourceURL for easier debugging.\n\t    var sourceURL = \'//# sourceURL=\' +\n\t      (\'sourceURL\' in options\n\t        ? options.sourceURL\n\t        : (\'lodash.templateSources[\' + (++templateCounter) + \']\')\n\t      ) + \'\\n\';\n\t\n\t    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n\t      interpolateValue || (interpolateValue = esTemplateValue);\n\t\n\t      // Escape characters that can\'t be included in string literals.\n\t      source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\t\n\t      // Replace delimiters with snippets.\n\t      if (escapeValue) {\n\t        isEscaping = true;\n\t        source += "\' +\\n__e(" + escapeValue + ") +\\n\'";\n\t      }\n\t      if (evaluateValue) {\n\t        isEvaluating = true;\n\t        source += "\';\\n" + evaluateValue + ";\\n__p += \'";\n\t      }\n\t      if (interpolateValue) {\n\t        source += "\' +\\n((__t = (" + interpolateValue + ")) == null ? \'\' : __t) +\\n\'";\n\t      }\n\t      index = offset + match.length;\n\t\n\t      // The JS engine embedded in Adobe products requires returning the `match`\n\t      // string in order to produce the correct `offset` value.\n\t      return match;\n\t    });\n\t\n\t    source += "\';\\n";\n\t\n\t    // If `variable` is not specified wrap a with-statement around the generated\n\t    // code to add the data object to the top of the scope chain.\n\t    var variable = options.variable;\n\t    if (!variable) {\n\t      source = \'with (obj) {\\n\' + source + \'\\n}\\n\';\n\t    }\n\t    // Cleanup code by stripping empty strings.\n\t    source = (isEvaluating ? source.replace(reEmptyStringLeading, \'\') : source)\n\t      .replace(reEmptyStringMiddle, \'$1\')\n\t      .replace(reEmptyStringTrailing, \'$1;\');\n\t\n\t    // Frame code as the function body.\n\t    source = \'function(\' + (variable || \'obj\') + \') {\\n\' +\n\t      (variable\n\t        ? \'\'\n\t        : \'obj || (obj = {});\\n\'\n\t      ) +\n\t      "var __t, __p = \'\'" +\n\t      (isEscaping\n\t         ? \', __e = _.escape\'\n\t         : \'\'\n\t      ) +\n\t      (isEvaluating\n\t        ? \', __j = Array.prototype.join;\\n\' +\n\t          "function print() { __p += __j.call(arguments, \'\') }\\n"\n\t        : \';\\n\'\n\t      ) +\n\t      source +\n\t      \'return __p\\n}\';\n\t\n\t    var result = attempt(function() {\n\t      return Function(importsKeys, sourceURL + \'return \' + source).apply(undefined, importsValues);\n\t    });\n\t\n\t    // Provide the compiled function\'s source by its `toString` method or\n\t    // the `source` property as a convenience for inlining compiled templates.\n\t    result.source = source;\n\t    if (isError(result)) {\n\t      throw result;\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Attempts to invoke `func`, returning either the result or the caught error\n\t   * object. Any additional arguments are provided to `func` when it\'s invoked.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Utility\n\t   * @param {Function} func The function to attempt.\n\t   * @returns {*} Returns the `func` result or error object.\n\t   * @example\n\t   *\n\t   * // avoid throwing errors for invalid selectors\n\t   * var elements = _.attempt(function(selector) {\n\t   *   return document.querySelectorAll(selector);\n\t   * }, \'>_>\');\n\t   *\n\t   * if (_.isError(elements)) {\n\t   *   elements = [];\n\t   * }\n\t   */\n\t  var attempt = restParam(function(func, args) {\n\t    try {\n\t      return func.apply(undefined, args);\n\t    } catch(e) {\n\t      return isError(e) ? e : new Error(e);\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Creates a function that invokes `func` with the `this` binding of `thisArg`\n\t   * and arguments of the created function. If `func` is a property name the\n\t   * created callback returns the property value for a given element. If `func`\n\t   * is an object the created callback returns `true` for elements that contain\n\t   * the equivalent object properties, otherwise it returns `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @alias iteratee\n\t   * @category Utility\n\t   * @param {*} [func=_.identity] The value to convert to a callback.\n\t   * @param {*} [thisArg] The `this` binding of `func`.\n\t   * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t   * @returns {Function} Returns the callback.\n\t   * @example\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\', \'age\': 36 },\n\t   *   { \'user\': \'fred\',   \'age\': 40 }\n\t   * ];\n\t   *\n\t   * // wrap to create custom callback shorthands\n\t   * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {\n\t   *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);\n\t   *   if (!match) {\n\t   *     return callback(func, thisArg);\n\t   *   }\n\t   *   return function(object) {\n\t   *     return match[2] == \'gt\'\n\t   *       ? object[match[1]] > match[3]\n\t   *       : object[match[1]] < match[3];\n\t   *   };\n\t   * });\n\t   *\n\t   * _.filter(users, \'age__gt36\');\n\t   * // => [{ \'user\': \'fred\', \'age\': 40 }]\n\t   */\n\t  function callback(func, thisArg, guard) {\n\t    if (guard && isIterateeCall(func, thisArg, guard)) {\n\t      thisArg = undefined;\n\t    }\n\t    return isObjectLike(func)\n\t      ? matches(func)\n\t      : baseCallback(func, thisArg);\n\t  }\n\t\n\t  /**\n\t   * This method returns the first argument provided to it.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Utility\n\t   * @param {*} value Any value.\n\t   * @returns {*} Returns `value`.\n\t   * @example\n\t   *\n\t   * var object = { \'user\': \'fred\' };\n\t   *\n\t   * _.identity(object) === object;\n\t   * // => true\n\t   */\n\t  function identity(value) {\n\t    return value;\n\t  }\n\t\n\t  /**\n\t   * Creates a function that performs a deep comparison between a given object\n\t   * and `source`, returning `true` if the given object has equivalent property\n\t   * values, else `false`.\n\t   *\n\t   * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t   * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t   * their own, not inherited, enumerable properties. For comparing a single\n\t   * own or inherited property value see `_.matchesProperty`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Utility\n\t   * @param {Object} source The object of property values to match.\n\t   * @returns {Function} Returns the new function.\n\t   * @example\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\', \'age\': 36, \'active\': true },\n\t   *   { \'user\': \'fred\',   \'age\': 40, \'active\': false }\n\t   * ];\n\t   *\n\t   * _.filter(users, _.matches({ \'age\': 40, \'active\': false }));\n\t   * // => [{ \'user\': \'fred\', \'age\': 40, \'active\': false }]\n\t   */\n\t  function matches(source) {\n\t    return baseMatches(baseClone(source, true));\n\t  }\n\t\n\t  /**\n\t   * A no-operation function that returns `undefined` regardless of the\n\t   * arguments it receives.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Utility\n\t   * @example\n\t   *\n\t   * var object = { \'user\': \'fred\' };\n\t   *\n\t   * _.noop(object) === undefined;\n\t   * // => true\n\t   */\n\t  function noop() {\n\t    // No operation performed.\n\t  }\n\t\n\t  /**\n\t   * Creates a function that returns the property value at `path` on a\n\t   * given object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Utility\n\t   * @param {Array|string} path The path of the property to get.\n\t   * @returns {Function} Returns the new function.\n\t   * @example\n\t   *\n\t   * var objects = [\n\t   *   { \'a\': { \'b\': { \'c\': 2 } } },\n\t   *   { \'a\': { \'b\': { \'c\': 1 } } }\n\t   * ];\n\t   *\n\t   * _.map(objects, _.property(\'a.b.c\'));\n\t   * // => [2, 1]\n\t   *\n\t   * _.pluck(_.sortBy(objects, _.property([\'a\', \'b\', \'c\'])), \'a.b.c\');\n\t   * // => [1, 2]\n\t   */\n\t  function property(path) {\n\t    return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n\t  }\n\t\n\t  /**\n\t   * Invokes the iteratee function `n` times, returning an array of the results\n\t   * of each invocation. The `iteratee` is bound to `thisArg` and invoked with\n\t   * one argument; (index).\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Utility\n\t   * @param {number} n The number of times to invoke `iteratee`.\n\t   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {Array} Returns the array of results.\n\t   * @example\n\t   *\n\t   * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));\n\t   * // => [3, 6, 4]\n\t   *\n\t   * _.times(3, function(n) {\n\t   *   mage.castSpell(n);\n\t   * });\n\t   * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`\n\t   *\n\t   * _.times(3, function(n) {\n\t   *   this.cast(n);\n\t   * }, mage);\n\t   * // => also invokes `mage.castSpell(n)` three times\n\t   */\n\t  function times(n, iteratee, thisArg) {\n\t    n = nativeFloor(n);\n\t\n\t    // Exit early to avoid a JSC JIT bug in Safari 8\n\t    // where `Array(0)` is treated as `Array(1)`.\n\t    if (n < 1 || !nativeIsFinite(n)) {\n\t      return [];\n\t    }\n\t    var index = -1,\n\t        result = Array(nativeMin(n, MAX_ARRAY_LENGTH));\n\t\n\t    iteratee = bindCallback(iteratee, thisArg, 1);\n\t    while (++index < n) {\n\t      if (index < MAX_ARRAY_LENGTH) {\n\t        result[index] = iteratee(index);\n\t      } else {\n\t        iteratee(index);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Generates a unique ID. If `prefix` is provided the ID is appended to it.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Utility\n\t   * @param {string} [prefix] The value to prefix the ID with.\n\t   * @returns {string} Returns the unique ID.\n\t   * @example\n\t   *\n\t   * _.uniqueId(\'contact_\');\n\t   * // => \'contact_104\'\n\t   *\n\t   * _.uniqueId();\n\t   * // => \'105\'\n\t   */\n\t  function uniqueId(prefix) {\n\t    var id = ++idCounter;\n\t    return baseToString(prefix) + id;\n\t  }\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Gets the maximum value of `collection`. If `collection` is empty or falsey\n\t   * `-Infinity` is returned. If an iteratee function is provided it\'s invoked\n\t   * for each value in `collection` to generate the criterion by which the value\n\t   * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n\t   * arguments: (value, index, collection).\n\t   *\n\t   * If a property name is provided for `iteratee` the created `_.property`\n\t   * style callback returns the property value of the given element.\n\t   *\n\t   * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t   * style callback returns `true` for elements that have a matching property\n\t   * value, else `false`.\n\t   *\n\t   * If an object is provided for `iteratee` the created `_.matches` style\n\t   * callback returns `true` for elements that have the properties of the given\n\t   * object, else `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Math\n\t   * @param {Array|Object|string} collection The collection to iterate over.\n\t   * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n\t   * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t   * @returns {*} Returns the maximum value.\n\t   * @example\n\t   *\n\t   * _.max([4, 2, 8, 6]);\n\t   * // => 8\n\t   *\n\t   * _.max([]);\n\t   * // => -Infinity\n\t   *\n\t   * var users = [\n\t   *   { \'user\': \'barney\', \'age\': 36 },\n\t   *   { \'user\': \'fred\',   \'age\': 40 }\n\t   * ];\n\t   *\n\t   * _.max(users, function(chr) {\n\t   *   return chr.age;\n\t   * });\n\t   * // => { \'user\': \'fred\', \'age\': 40 }\n\t   *\n\t   * // using the `_.property` callback shorthand\n\t   * _.max(users, \'age\');\n\t   * // => { \'user\': \'fred\', \'age\': 40 }\n\t   */\n\t  var max = createExtremum(gt, NEGATIVE_INFINITY);\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n\t  LazyWrapper.prototype.constructor = LazyWrapper;\n\t\n\t  // Add functions to the `Set` cache.\n\t  SetCache.prototype.push = cachePush;\n\t\n\t  // Add functions that return wrapped values when chaining.\n\t  lodash.assign = assign;\n\t  lodash.bind = bind;\n\t  lodash.bindAll = bindAll;\n\t  lodash.callback = callback;\n\t  lodash.compact = compact;\n\t  lodash.countBy = countBy;\n\t  lodash.create = create;\n\t  lodash.debounce = debounce;\n\t  lodash.defaults = defaults;\n\t  lodash.defaultsDeep = defaultsDeep;\n\t  lodash.difference = difference;\n\t  lodash.filter = filter;\n\t  lodash.flatten = flatten;\n\t  lodash.flattenDeep = flattenDeep;\n\t  lodash.forEach = forEach;\n\t  lodash.forOwn = forOwn;\n\t  lodash.functions = functions;\n\t  lodash.invert = invert;\n\t  lodash.keys = keys;\n\t  lodash.keysIn = keysIn;\n\t  lodash.map = map;\n\t  lodash.mapKeys = mapKeys;\n\t  lodash.mapValues = mapValues;\n\t  lodash.matches = matches;\n\t  lodash.merge = merge;\n\t  lodash.omit = omit;\n\t  lodash.pairs = pairs;\n\t  lodash.pick = pick;\n\t  lodash.pluck = pluck;\n\t  lodash.property = property;\n\t  lodash.remove = remove;\n\t  lodash.restParam = restParam;\n\t  lodash.set = set;\n\t  lodash.sortBy = sortBy;\n\t  lodash.throttle = throttle;\n\t  lodash.times = times;\n\t  lodash.toPlainObject = toPlainObject;\n\t  lodash.union = union;\n\t  lodash.uniq = uniq;\n\t  lodash.values = values;\n\t\n\t  // Add aliases.\n\t  lodash.collect = map;\n\t  lodash.each = forEach;\n\t  lodash.extend = assign;\n\t  lodash.iteratee = callback;\n\t  lodash.methods = functions;\n\t  lodash.select = filter;\n\t  lodash.unique = uniq;\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  // Add functions that return unwrapped values when chaining.\n\t  lodash.attempt = attempt;\n\t  lodash.clone = clone;\n\t  lodash.cloneDeep = cloneDeep;\n\t  lodash.endsWith = endsWith;\n\t  lodash.escape = escape;\n\t  lodash.every = every;\n\t  lodash.find = find;\n\t  lodash.get = get;\n\t  lodash.gt = gt;\n\t  lodash.identity = identity;\n\t  lodash.includes = includes;\n\t  lodash.indexOf = indexOf;\n\t  lodash.isArguments = isArguments;\n\t  lodash.isArray = isArray;\n\t  lodash.isBoolean = isBoolean;\n\t  lodash.isEmpty = isEmpty;\n\t  lodash.isError = isError;\n\t  lodash.isFunction = isFunction;\n\t  lodash.isNaN = isNaN;\n\t  lodash.isNative = isNative;\n\t  lodash.isNull = isNull;\n\t  lodash.isNumber = isNumber;\n\t  lodash.isObject = isObject;\n\t  lodash.isPlainObject = isPlainObject;\n\t  lodash.isString = isString;\n\t  lodash.isTypedArray = isTypedArray;\n\t  lodash.isUndefined = isUndefined;\n\t  lodash.last = last;\n\t  lodash.max = max;\n\t  lodash.noop = noop;\n\t  lodash.now = now;\n\t  lodash.padLeft = padLeft;\n\t  lodash.random = random;\n\t  lodash.reduce = reduce;\n\t  lodash.repeat = repeat;\n\t  lodash.size = size;\n\t  lodash.some = some;\n\t  lodash.startsWith = startsWith;\n\t  lodash.template = template;\n\t  lodash.uniqueId = uniqueId;\n\t\n\t  // Add aliases.\n\t  lodash.all = every;\n\t  lodash.any = some;\n\t  lodash.contains = includes;\n\t  lodash.detect = find;\n\t  lodash.foldl = reduce;\n\t  lodash.include = includes;\n\t  lodash.inject = reduce;\n\t\n\t  /*------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * The semantic version number.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @type string\n\t   */\n\t  lodash.VERSION = VERSION;\n\t\n\t  // Assign default placeholders.\n\t  bind.placeholder = lodash;\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  // Some AMD build optimizers like r.js check for condition patterns like the following:\n\t  if (true) {\n\t    // Define as an anonymous module so, through path mapping, it can be\n\t    // referenced as the "underscore" module.\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return lodash;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}.call(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)(module), (function() { return this; }())))\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t  \'use strict\';\n\t\n\t  try {\n\t    var overrideSettings = window.parent.SPXSettings;\n\t\n\t    if (overrideSettings && overrideSettings.globalObject) {\n\t      return overrideSettings.globalObject;\n\t    } else {\n\t      return window.top;\n\t    }\n\t  } catch(e) {\n\t    console.log(\'[spx] Unable to access SPXSettings: \', e);\n\t  }\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ })\n/******/ ])));');